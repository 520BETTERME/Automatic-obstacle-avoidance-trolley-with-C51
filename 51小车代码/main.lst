                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ANSI-C Compiler
                                      3 ; Version 3.8.3 #10694 (MINGW32)
                                      4 ;--------------------------------------------------------
                                      5 	.module main
                                      6 	.optsdcc -mmcs51 --model-small
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _seg
                                     12 	.globl _main
                                     13 	.globl _timer2
                                     14 	.globl _serial
                                     15 	.globl _int1
                                     16 	.globl _timer0
                                     17 	.globl _putcharToSer
                                     18 	.globl _CY
                                     19 	.globl _AC
                                     20 	.globl _F0
                                     21 	.globl _RS1
                                     22 	.globl _RS0
                                     23 	.globl _OV
                                     24 	.globl _FL
                                     25 	.globl _P
                                     26 	.globl _TF2
                                     27 	.globl _EXF2
                                     28 	.globl _RCLK
                                     29 	.globl _TCLK
                                     30 	.globl _EXEN2
                                     31 	.globl _TR2
                                     32 	.globl _C_T2
                                     33 	.globl _CP_RL2
                                     34 	.globl _T2CON_7
                                     35 	.globl _T2CON_6
                                     36 	.globl _T2CON_5
                                     37 	.globl _T2CON_4
                                     38 	.globl _T2CON_3
                                     39 	.globl _T2CON_2
                                     40 	.globl _T2CON_1
                                     41 	.globl _T2CON_0
                                     42 	.globl _PT2
                                     43 	.globl _PS
                                     44 	.globl _PT1
                                     45 	.globl _PX1
                                     46 	.globl _PT0
                                     47 	.globl _PX0
                                     48 	.globl _RD
                                     49 	.globl _WR
                                     50 	.globl _T1
                                     51 	.globl _T0
                                     52 	.globl _INT1
                                     53 	.globl _INT0
                                     54 	.globl _TXD
                                     55 	.globl _RXD
                                     56 	.globl _P3_7
                                     57 	.globl _P3_6
                                     58 	.globl _P3_5
                                     59 	.globl _P3_4
                                     60 	.globl _P3_3
                                     61 	.globl _P3_2
                                     62 	.globl _P3_1
                                     63 	.globl _P3_0
                                     64 	.globl _EA
                                     65 	.globl _ET2
                                     66 	.globl _ES
                                     67 	.globl _ET1
                                     68 	.globl _EX1
                                     69 	.globl _ET0
                                     70 	.globl _EX0
                                     71 	.globl _P2_7
                                     72 	.globl _P2_6
                                     73 	.globl _P2_5
                                     74 	.globl _P2_4
                                     75 	.globl _P2_3
                                     76 	.globl _P2_2
                                     77 	.globl _P2_1
                                     78 	.globl _P2_0
                                     79 	.globl _SM0
                                     80 	.globl _SM1
                                     81 	.globl _SM2
                                     82 	.globl _REN
                                     83 	.globl _TB8
                                     84 	.globl _RB8
                                     85 	.globl _TI
                                     86 	.globl _RI
                                     87 	.globl _T2EX
                                     88 	.globl _T2
                                     89 	.globl _P1_7
                                     90 	.globl _P1_6
                                     91 	.globl _P1_5
                                     92 	.globl _P1_4
                                     93 	.globl _P1_3
                                     94 	.globl _P1_2
                                     95 	.globl _P1_1
                                     96 	.globl _P1_0
                                     97 	.globl _TF1
                                     98 	.globl _TR1
                                     99 	.globl _TF0
                                    100 	.globl _TR0
                                    101 	.globl _IE1
                                    102 	.globl _IT1
                                    103 	.globl _IE0
                                    104 	.globl _IT0
                                    105 	.globl _P0_7
                                    106 	.globl _P0_6
                                    107 	.globl _P0_5
                                    108 	.globl _P0_4
                                    109 	.globl _P0_3
                                    110 	.globl _P0_2
                                    111 	.globl _P0_1
                                    112 	.globl _P0_0
                                    113 	.globl _B
                                    114 	.globl _A
                                    115 	.globl _ACC
                                    116 	.globl _PSW
                                    117 	.globl _TH2
                                    118 	.globl _TL2
                                    119 	.globl _RCAP2H
                                    120 	.globl _RCAP2L
                                    121 	.globl _T2MOD
                                    122 	.globl _T2CON
                                    123 	.globl _IP
                                    124 	.globl _P3
                                    125 	.globl _IE
                                    126 	.globl _P2
                                    127 	.globl _SBUF
                                    128 	.globl _SCON
                                    129 	.globl _P1
                                    130 	.globl _TH1
                                    131 	.globl _TH0
                                    132 	.globl _TL1
                                    133 	.globl _TL0
                                    134 	.globl _TMOD
                                    135 	.globl _TCON
                                    136 	.globl _PCON
                                    137 	.globl _DPH
                                    138 	.globl _DPL
                                    139 	.globl _SP
                                    140 	.globl _P0
                                    141 	.globl _setObsFlag_PARM_4
                                    142 	.globl _setObsFlag_PARM_3
                                    143 	.globl _setObsFlag_PARM_2
                                    144 	.globl _setObsFlag_PARM_1
                                    145 	.globl _rObsFlag
                                    146 	.globl _lObsFlag
                                    147 	.globl _bObsFlag
                                    148 	.globl _fObsFlag
                                    149 	.globl _isFirst
                                    150 	.globl _isOverStep
                                    151 	.globl _angle
                                    152 	.globl _t2InterruptTimes
                                    153 	.globl _t0InterruptTimes
                                    154 	.globl _speed
                                    155 	.globl _operate
                                    156 	.globl _delay
                                    157 	.globl _sensorTrigger
                                    158 	.globl _setObsFlag
                                    159 	.globl _ledStatus
                                    160 	.globl _setTurnAngle
                                    161 	.globl _steerTurn
                                    162 	.globl _workSR04
                                    163 	.globl _calculate
                                    164 	.globl _isHaveObs
                                    165 	.globl _selfControl
                                    166 	.globl _btControl
                                    167 	.globl _initInterrupt
                                    168 	.globl _initTimer0
                                    169 	.globl _initSerial
                                    170 	.globl _initTimer2
                                    171 	.globl _setup
                                    172 	.globl _loop
                                    173 ;--------------------------------------------------------
                                    174 ; special function registers
                                    175 ;--------------------------------------------------------
                                    176 	.area RSEG    (ABS,DATA)
      000000                        177 	.org 0x0000
                           000080   178 _P0	=	0x0080
                           000081   179 _SP	=	0x0081
                           000082   180 _DPL	=	0x0082
                           000083   181 _DPH	=	0x0083
                           000087   182 _PCON	=	0x0087
                           000088   183 _TCON	=	0x0088
                           000089   184 _TMOD	=	0x0089
                           00008A   185 _TL0	=	0x008a
                           00008B   186 _TL1	=	0x008b
                           00008C   187 _TH0	=	0x008c
                           00008D   188 _TH1	=	0x008d
                           000090   189 _P1	=	0x0090
                           000098   190 _SCON	=	0x0098
                           000099   191 _SBUF	=	0x0099
                           0000A0   192 _P2	=	0x00a0
                           0000A8   193 _IE	=	0x00a8
                           0000B0   194 _P3	=	0x00b0
                           0000B8   195 _IP	=	0x00b8
                           0000C8   196 _T2CON	=	0x00c8
                           0000C9   197 _T2MOD	=	0x00c9
                           0000CA   198 _RCAP2L	=	0x00ca
                           0000CB   199 _RCAP2H	=	0x00cb
                           0000CC   200 _TL2	=	0x00cc
                           0000CD   201 _TH2	=	0x00cd
                           0000D0   202 _PSW	=	0x00d0
                           0000E0   203 _ACC	=	0x00e0
                           0000E0   204 _A	=	0x00e0
                           0000F0   205 _B	=	0x00f0
                                    206 ;--------------------------------------------------------
                                    207 ; special function bits
                                    208 ;--------------------------------------------------------
                                    209 	.area RSEG    (ABS,DATA)
      000000                        210 	.org 0x0000
                           000080   211 _P0_0	=	0x0080
                           000081   212 _P0_1	=	0x0081
                           000082   213 _P0_2	=	0x0082
                           000083   214 _P0_3	=	0x0083
                           000084   215 _P0_4	=	0x0084
                           000085   216 _P0_5	=	0x0085
                           000086   217 _P0_6	=	0x0086
                           000087   218 _P0_7	=	0x0087
                           000088   219 _IT0	=	0x0088
                           000089   220 _IE0	=	0x0089
                           00008A   221 _IT1	=	0x008a
                           00008B   222 _IE1	=	0x008b
                           00008C   223 _TR0	=	0x008c
                           00008D   224 _TF0	=	0x008d
                           00008E   225 _TR1	=	0x008e
                           00008F   226 _TF1	=	0x008f
                           000090   227 _P1_0	=	0x0090
                           000091   228 _P1_1	=	0x0091
                           000092   229 _P1_2	=	0x0092
                           000093   230 _P1_3	=	0x0093
                           000094   231 _P1_4	=	0x0094
                           000095   232 _P1_5	=	0x0095
                           000096   233 _P1_6	=	0x0096
                           000097   234 _P1_7	=	0x0097
                           000090   235 _T2	=	0x0090
                           000091   236 _T2EX	=	0x0091
                           000098   237 _RI	=	0x0098
                           000099   238 _TI	=	0x0099
                           00009A   239 _RB8	=	0x009a
                           00009B   240 _TB8	=	0x009b
                           00009C   241 _REN	=	0x009c
                           00009D   242 _SM2	=	0x009d
                           00009E   243 _SM1	=	0x009e
                           00009F   244 _SM0	=	0x009f
                           0000A0   245 _P2_0	=	0x00a0
                           0000A1   246 _P2_1	=	0x00a1
                           0000A2   247 _P2_2	=	0x00a2
                           0000A3   248 _P2_3	=	0x00a3
                           0000A4   249 _P2_4	=	0x00a4
                           0000A5   250 _P2_5	=	0x00a5
                           0000A6   251 _P2_6	=	0x00a6
                           0000A7   252 _P2_7	=	0x00a7
                           0000A8   253 _EX0	=	0x00a8
                           0000A9   254 _ET0	=	0x00a9
                           0000AA   255 _EX1	=	0x00aa
                           0000AB   256 _ET1	=	0x00ab
                           0000AC   257 _ES	=	0x00ac
                           0000AD   258 _ET2	=	0x00ad
                           0000AF   259 _EA	=	0x00af
                           0000B0   260 _P3_0	=	0x00b0
                           0000B1   261 _P3_1	=	0x00b1
                           0000B2   262 _P3_2	=	0x00b2
                           0000B3   263 _P3_3	=	0x00b3
                           0000B4   264 _P3_4	=	0x00b4
                           0000B5   265 _P3_5	=	0x00b5
                           0000B6   266 _P3_6	=	0x00b6
                           0000B7   267 _P3_7	=	0x00b7
                           0000B0   268 _RXD	=	0x00b0
                           0000B1   269 _TXD	=	0x00b1
                           0000B2   270 _INT0	=	0x00b2
                           0000B3   271 _INT1	=	0x00b3
                           0000B4   272 _T0	=	0x00b4
                           0000B5   273 _T1	=	0x00b5
                           0000B6   274 _WR	=	0x00b6
                           0000B7   275 _RD	=	0x00b7
                           0000B8   276 _PX0	=	0x00b8
                           0000B9   277 _PT0	=	0x00b9
                           0000BA   278 _PX1	=	0x00ba
                           0000BB   279 _PT1	=	0x00bb
                           0000BC   280 _PS	=	0x00bc
                           0000BD   281 _PT2	=	0x00bd
                           0000C8   282 _T2CON_0	=	0x00c8
                           0000C9   283 _T2CON_1	=	0x00c9
                           0000CA   284 _T2CON_2	=	0x00ca
                           0000CB   285 _T2CON_3	=	0x00cb
                           0000CC   286 _T2CON_4	=	0x00cc
                           0000CD   287 _T2CON_5	=	0x00cd
                           0000CE   288 _T2CON_6	=	0x00ce
                           0000CF   289 _T2CON_7	=	0x00cf
                           0000C8   290 _CP_RL2	=	0x00c8
                           0000C9   291 _C_T2	=	0x00c9
                           0000CA   292 _TR2	=	0x00ca
                           0000CB   293 _EXEN2	=	0x00cb
                           0000CC   294 _TCLK	=	0x00cc
                           0000CD   295 _RCLK	=	0x00cd
                           0000CE   296 _EXF2	=	0x00ce
                           0000CF   297 _TF2	=	0x00cf
                           0000D0   298 _P	=	0x00d0
                           0000D1   299 _FL	=	0x00d1
                           0000D2   300 _OV	=	0x00d2
                           0000D3   301 _RS0	=	0x00d3
                           0000D4   302 _RS1	=	0x00d4
                           0000D5   303 _F0	=	0x00d5
                           0000D6   304 _AC	=	0x00d6
                           0000D7   305 _CY	=	0x00d7
                                    306 ;--------------------------------------------------------
                                    307 ; overlayable register banks
                                    308 ;--------------------------------------------------------
                                    309 	.area REG_BANK_0	(REL,OVR,DATA)
      000000                        310 	.ds 8
                                    311 	.area REG_BANK_1	(REL,OVR,DATA)
      000000                        312 	.ds 8
                                    313 	.area REG_BANK_2	(REL,OVR,DATA)
      000000                        314 	.ds 8
                                    315 	.area REG_BANK_3	(REL,OVR,DATA)
      000000                        316 	.ds 8
                                    317 ;--------------------------------------------------------
                                    318 ; overlayable bit register bank
                                    319 ;--------------------------------------------------------
                                    320 	.area BIT_BANK	(REL,OVR,DATA)
      000000                        321 bits:
      000000                        322 	.ds 1
                           008000   323 	b0 = bits[0]
                           008100   324 	b1 = bits[1]
                           008200   325 	b2 = bits[2]
                           008300   326 	b3 = bits[3]
                           008400   327 	b4 = bits[4]
                           008500   328 	b5 = bits[5]
                           008600   329 	b6 = bits[6]
                           008700   330 	b7 = bits[7]
                                    331 ;--------------------------------------------------------
                                    332 ; internal ram data
                                    333 ;--------------------------------------------------------
                                    334 	.area DSEG    (DATA)
      000000                        335 _operate::
      000000                        336 	.ds 1
      000001                        337 _speed::
      000001                        338 	.ds 1
      000002                        339 _t0InterruptTimes::
      000002                        340 	.ds 2
      000004                        341 _t2InterruptTimes::
      000004                        342 	.ds 2
      000006                        343 _angle::
      000006                        344 	.ds 1
                                    345 ;--------------------------------------------------------
                                    346 ; overlayable items in internal ram 
                                    347 ;--------------------------------------------------------
                                    348 	.area	OSEG    (OVR,DATA)
                                    349 	.area	OSEG    (OVR,DATA)
                                    350 	.area	OSEG    (OVR,DATA)
                                    351 	.area	OSEG    (OVR,DATA)
                                    352 	.area	OSEG    (OVR,DATA)
                                    353 ;--------------------------------------------------------
                                    354 ; Stack segment in internal ram 
                                    355 ;--------------------------------------------------------
                                    356 	.area	SSEG
      000000                        357 __start__stack:
      000000                        358 	.ds	1
                                    359 
                                    360 ;--------------------------------------------------------
                                    361 ; indirectly addressable internal ram data
                                    362 ;--------------------------------------------------------
                                    363 	.area ISEG    (DATA)
                                    364 ;--------------------------------------------------------
                                    365 ; absolute internal ram data
                                    366 ;--------------------------------------------------------
                                    367 	.area IABS    (ABS,DATA)
                                    368 	.area IABS    (ABS,DATA)
                                    369 ;--------------------------------------------------------
                                    370 ; bit data
                                    371 ;--------------------------------------------------------
                                    372 	.area BSEG    (BIT)
      000000                        373 _isOverStep::
      000000                        374 	.ds 1
      000001                        375 _isFirst::
      000001                        376 	.ds 1
      000002                        377 _fObsFlag::
      000002                        378 	.ds 1
      000003                        379 _bObsFlag::
      000003                        380 	.ds 1
      000004                        381 _lObsFlag::
      000004                        382 	.ds 1
      000005                        383 _rObsFlag::
      000005                        384 	.ds 1
      000006                        385 _setObsFlag_PARM_1:
      000006                        386 	.ds 1
      000007                        387 _setObsFlag_PARM_2:
      000007                        388 	.ds 1
      000008                        389 _setObsFlag_PARM_3:
      000008                        390 	.ds 1
      000009                        391 _setObsFlag_PARM_4:
      000009                        392 	.ds 1
                                    393 ;--------------------------------------------------------
                                    394 ; paged external ram data
                                    395 ;--------------------------------------------------------
                                    396 	.area PSEG    (PAG,XDATA)
                                    397 ;--------------------------------------------------------
                                    398 ; external ram data
                                    399 ;--------------------------------------------------------
                                    400 	.area XSEG    (XDATA)
                                    401 ;--------------------------------------------------------
                                    402 ; absolute external ram data
                                    403 ;--------------------------------------------------------
                                    404 	.area XABS    (ABS,XDATA)
                                    405 ;--------------------------------------------------------
                                    406 ; external initialized ram data
                                    407 ;--------------------------------------------------------
                                    408 	.area XISEG   (XDATA)
                                    409 	.area HOME    (CODE)
                                    410 	.area GSINIT0 (CODE)
                                    411 	.area GSINIT1 (CODE)
                                    412 	.area GSINIT2 (CODE)
                                    413 	.area GSINIT3 (CODE)
                                    414 	.area GSINIT4 (CODE)
                                    415 	.area GSINIT5 (CODE)
                                    416 	.area GSINIT  (CODE)
                                    417 	.area GSFINAL (CODE)
                                    418 	.area CSEG    (CODE)
                                    419 ;--------------------------------------------------------
                                    420 ; interrupt vector 
                                    421 ;--------------------------------------------------------
                                    422 	.area HOME    (CODE)
      000000                        423 __interrupt_vect:
      000000 02r00r00         [24]  424 	ljmp	__sdcc_gsinit_startup
      000003 32               [24]  425 	reti
      000004                        426 	.ds	7
      00000B 02r04rD8         [24]  427 	ljmp	_timer0
      00000E                        428 	.ds	5
      000013 02r05r31         [24]  429 	ljmp	_int1
      000016                        430 	.ds	5
      00001B 32               [24]  431 	reti
      00001C                        432 	.ds	7
      000023 02r05r37         [24]  433 	ljmp	_serial
      000026                        434 	.ds	5
      00002B 02r05r45         [24]  435 	ljmp	_timer2
                                    436 ;--------------------------------------------------------
                                    437 ; global & static initialisations
                                    438 ;--------------------------------------------------------
                                    439 	.area HOME    (CODE)
                                    440 	.area GSINIT  (CODE)
                                    441 	.area GSFINAL (CODE)
                                    442 	.area GSINIT  (CODE)
                                    443 	.globl __sdcc_gsinit_startup
                                    444 	.globl __sdcc_program_startup
                                    445 	.globl __start__stack
                                    446 	.globl __mcs51_genXINIT
                                    447 	.globl __mcs51_genXRAMCLEAR
                                    448 	.globl __mcs51_genRAMCLEAR
                                    449 ;	main.c:69: uchar operate = 0;
      000000 75*00 00         [24]  450 	mov	_operate,#0x00
                                    451 ;	main.c:75: uchar speed = 8;	//小车速度
      000003 75*01 08         [24]  452 	mov	_speed,#0x08
                                    453 ;	main.c:79: __bit isOverStep = 0;	//定时器0是否溢出标志，溢出距离过远，超出测量范围
                                    454 ;	assignBit
      000006 C2*00            [12]  455 	clr	_isOverStep
                                    456 ;	main.c:80: __bit isFirst = 1;
                                    457 ;	assignBit
      000008 D2*01            [12]  458 	setb	_isFirst
                                    459 ;	main.c:81: __bit fObsFlag = 0;		//前面障碍物标志
                                    460 ;	assignBit
      00000A C2*02            [12]  461 	clr	_fObsFlag
                                    462 ;	main.c:82: __bit bObsFlag = 0;		//后面障碍物标志
                                    463 ;	assignBit
      00000C C2*03            [12]  464 	clr	_bObsFlag
                                    465 ;	main.c:83: __bit lObsFlag = 0;		//左面障碍物标志
                                    466 ;	assignBit
      00000E C2*04            [12]  467 	clr	_lObsFlag
                                    468 ;	main.c:84: __bit rObsFlag = 0;		//右面障碍物标志
                                    469 ;	assignBit
      000010 C2*05            [12]  470 	clr	_rObsFlag
                                    471 	.area GSFINAL (CODE)
      000000 02r00r2E         [24]  472 	ljmp	__sdcc_program_startup
                                    473 ;--------------------------------------------------------
                                    474 ; Home
                                    475 ;--------------------------------------------------------
                                    476 	.area HOME    (CODE)
                                    477 	.area HOME    (CODE)
      00002E                        478 __sdcc_program_startup:
      00002E 02r06r05         [24]  479 	ljmp	_main
                                    480 ;	return from main will return to caller
                                    481 ;--------------------------------------------------------
                                    482 ; code
                                    483 ;--------------------------------------------------------
                                    484 	.area CSEG    (CODE)
                                    485 ;------------------------------------------------------------
                                    486 ;Allocation info for local variables in function 'delay'
                                    487 ;------------------------------------------------------------
                                    488 ;n                         Allocated to registers 
                                    489 ;i                         Allocated to registers r6 r7 
                                    490 ;j                         Allocated to registers r4 r5 
                                    491 ;------------------------------------------------------------
                                    492 ;	main.c:88: void delay(uint n){
                                    493 ;	-----------------------------------------
                                    494 ;	 function delay
                                    495 ;	-----------------------------------------
      000000                        496 _delay:
                           000007   497 	ar7 = 0x07
                           000006   498 	ar6 = 0x06
                           000005   499 	ar5 = 0x05
                           000004   500 	ar4 = 0x04
                           000003   501 	ar3 = 0x03
                           000002   502 	ar2 = 0x02
                           000001   503 	ar1 = 0x01
                           000000   504 	ar0 = 0x00
      000000 AE 82            [24]  505 	mov	r6,dpl
      000002 AF 83            [24]  506 	mov	r7,dph
                                    507 ;	main.c:90: for(i=n;i>0;i--){
      000004                        508 00106$:
      000004 EE               [12]  509 	mov	a,r6
      000005 4F               [12]  510 	orl	a,r7
      000006 60 1B            [24]  511 	jz	00108$
                                    512 ;	main.c:91: for(j=112;j>0;j--);
      000008 7C 70            [12]  513 	mov	r4,#0x70
      00000A 7D 00            [12]  514 	mov	r5,#0x00
      00000C                        515 00104$:
      00000C EC               [12]  516 	mov	a,r4
      00000D 24 FF            [12]  517 	add	a,#0xff
      00000F FA               [12]  518 	mov	r2,a
      000010 ED               [12]  519 	mov	a,r5
      000011 34 FF            [12]  520 	addc	a,#0xff
      000013 FB               [12]  521 	mov	r3,a
      000014 8A 04            [24]  522 	mov	ar4,r2
      000016 8B 05            [24]  523 	mov	ar5,r3
      000018 EA               [12]  524 	mov	a,r2
      000019 4B               [12]  525 	orl	a,r3
      00001A 70 F0            [24]  526 	jnz	00104$
                                    527 ;	main.c:90: for(i=n;i>0;i--){
      00001C 1E               [12]  528 	dec	r6
      00001D BE FF 01         [24]  529 	cjne	r6,#0xff,00133$
      000020 1F               [12]  530 	dec	r7
      000021                        531 00133$:
      000021 80 E1            [24]  532 	sjmp	00106$
      000023                        533 00108$:
                                    534 ;	main.c:93: }
      000023 22               [24]  535 	ret
                                    536 ;------------------------------------------------------------
                                    537 ;Allocation info for local variables in function 'putcharToSer'
                                    538 ;------------------------------------------------------------
                                    539 ;c                         Allocated to registers 
                                    540 ;------------------------------------------------------------
                                    541 ;	main.c:96: void  putcharToSer(char c) {
                                    542 ;	-----------------------------------------
                                    543 ;	 function putcharToSer
                                    544 ;	-----------------------------------------
      000024                        545 _putcharToSer:
      000024 85 82 99         [24]  546 	mov	_SBUF,dpl
                                    547 ;	main.c:98: while(!TI);
      000027                        548 00101$:
                                    549 ;	main.c:99: TI = 0;
                                    550 ;	assignBit
      000027 10 99 02         [24]  551 	jbc	_TI,00114$
      00002A 80 FB            [24]  552 	sjmp	00101$
      00002C                        553 00114$:
                                    554 ;	main.c:100: }
      00002C 22               [24]  555 	ret
                                    556 ;------------------------------------------------------------
                                    557 ;Allocation info for local variables in function 'sensorTrigger'
                                    558 ;------------------------------------------------------------
                                    559 ;	main.c:103: void sensorTrigger() {
                                    560 ;	-----------------------------------------
                                    561 ;	 function sensorTrigger
                                    562 ;	-----------------------------------------
      00002D                        563 _sensorTrigger:
                                    564 ;	main.c:104: if(!(BACK_SENSER & FRONT_SENSER & LEFT_SENSER & RIGHT_SENSER)) {
      00002D A2 95            [12]  565 	mov	c,_P1_5
      00002F 82 94            [24]  566 	anl	c,_P1_4
      000031 82 96            [24]  567 	anl	c,_P1_6
      000033 82 97            [24]  568 	anl	c,_P1_7
      000035 40 03            [24]  569 	jc	00102$
                                    570 ;	main.c:105: SWITCH_SELF_CONTROL = 0;
                                    571 ;	assignBit
      000037 C2 90            [12]  572 	clr	_P1_0
      000039 22               [24]  573 	ret
      00003A                        574 00102$:
                                    575 ;	main.c:108: SWITCH_SELF_CONTROL = 1;
                                    576 ;	assignBit
      00003A D2 90            [12]  577 	setb	_P1_0
                                    578 ;	main.c:110: }
      00003C 22               [24]  579 	ret
                                    580 ;------------------------------------------------------------
                                    581 ;Allocation info for local variables in function 'setObsFlag'
                                    582 ;------------------------------------------------------------
                                    583 ;	main.c:113: void setObsFlag(__bit fof, __bit bof, __bit lof, __bit rof) {
                                    584 ;	-----------------------------------------
                                    585 ;	 function setObsFlag
                                    586 ;	-----------------------------------------
      00003D                        587 _setObsFlag:
                                    588 ;	main.c:114: fObsFlag = fof;
                                    589 ;	assignBit
      00003D A2*06            [12]  590 	mov	c,_setObsFlag_PARM_1
      00003F 92*02            [24]  591 	mov	_fObsFlag,c
                                    592 ;	main.c:115: bObsFlag = bof;
                                    593 ;	assignBit
      000041 A2*07            [12]  594 	mov	c,_setObsFlag_PARM_2
      000043 92*03            [24]  595 	mov	_bObsFlag,c
                                    596 ;	main.c:116: lObsFlag = lof;
                                    597 ;	assignBit
      000045 A2*08            [12]  598 	mov	c,_setObsFlag_PARM_3
      000047 92*04            [24]  599 	mov	_lObsFlag,c
                                    600 ;	main.c:117: rObsFlag = rof;
                                    601 ;	assignBit
      000049 A2*09            [12]  602 	mov	c,_setObsFlag_PARM_4
      00004B 92*05            [24]  603 	mov	_rObsFlag,c
                                    604 ;	main.c:118: }
      00004D 22               [24]  605 	ret
                                    606 ;------------------------------------------------------------
                                    607 ;Allocation info for local variables in function 'ledStatus'
                                    608 ;------------------------------------------------------------
                                    609 ;s                         Allocated to registers r7 
                                    610 ;------------------------------------------------------------
                                    611 ;	main.c:122: void ledStatus(uchar s) {
                                    612 ;	-----------------------------------------
                                    613 ;	 function ledStatus
                                    614 ;	-----------------------------------------
      00004E                        615 _ledStatus:
      00004E AF 82            [24]  616 	mov	r7,dpl
                                    617 ;	main.c:123: switch(s) {
      000050 BF 00 02         [24]  618 	cjne	r7,#0x00,00119$
      000053 80 0A            [24]  619 	sjmp	00101$
      000055                        620 00119$:
      000055 BF 01 02         [24]  621 	cjne	r7,#0x01,00120$
      000058 80 0C            [24]  622 	sjmp	00102$
      00005A                        623 00120$:
                                    624 ;	main.c:124: case(0):
      00005A BF 02 16         [24]  625 	cjne	r7,#0x02,00105$
      00005D 80 0E            [24]  626 	sjmp	00103$
      00005F                        627 00101$:
                                    628 ;	main.c:125: STOP_RED_LED = 0;	//停止指示灯亮
                                    629 ;	assignBit
      00005F C2 91            [12]  630 	clr	_P1_1
                                    631 ;	main.c:126: BT_BLUE_LED = 1;
                                    632 ;	assignBit
      000061 D2 92            [12]  633 	setb	_P1_2
                                    634 ;	main.c:127: SELF_GREEN_LED = 1;
                                    635 ;	assignBit
      000063 D2 93            [12]  636 	setb	_P1_3
                                    637 ;	main.c:128: break;
                                    638 ;	main.c:129: case(1):
      000065 22               [24]  639 	ret
      000066                        640 00102$:
                                    641 ;	main.c:130: STOP_RED_LED = 1;
                                    642 ;	assignBit
      000066 D2 91            [12]  643 	setb	_P1_1
                                    644 ;	main.c:131: BT_BLUE_LED = 1;	  
                                    645 ;	assignBit
      000068 D2 92            [12]  646 	setb	_P1_2
                                    647 ;	main.c:132: SELF_GREEN_LED = 0;    //自控指示灯亮
                                    648 ;	assignBit
      00006A C2 93            [12]  649 	clr	_P1_3
                                    650 ;	main.c:133: break;
                                    651 ;	main.c:134: case(2):
      00006C 22               [24]  652 	ret
      00006D                        653 00103$:
                                    654 ;	main.c:135: STOP_RED_LED = 1;
                                    655 ;	assignBit
      00006D D2 91            [12]  656 	setb	_P1_1
                                    657 ;	main.c:136: SELF_GREEN_LED = 1;
                                    658 ;	assignBit
      00006F D2 93            [12]  659 	setb	_P1_3
                                    660 ;	main.c:137: BT_BLUE_LED = 0;	//蓝牙控制指示灯亮
                                    661 ;	assignBit
      000071 C2 92            [12]  662 	clr	_P1_2
                                    663 ;	main.c:139: }	
      000073                        664 00105$:
                                    665 ;	main.c:140: }
      000073 22               [24]  666 	ret
                                    667 ;------------------------------------------------------------
                                    668 ;Allocation info for local variables in function 'setTurnAngle'
                                    669 ;------------------------------------------------------------
                                    670 ;a                         Allocated to registers r7 
                                    671 ;------------------------------------------------------------
                                    672 ;	main.c:143: void setTurnAngle(uchar a) {
                                    673 ;	-----------------------------------------
                                    674 ;	 function setTurnAngle
                                    675 ;	-----------------------------------------
      000074                        676 _setTurnAngle:
      000074 AF 82            [24]  677 	mov	r7,dpl
                                    678 ;	main.c:145: switch(a) {
      000076 BF 05 02         [24]  679 	cjne	r7,#0x05,00129$
      000079 80 1A            [24]  680 	sjmp	00103$
      00007B                        681 00129$:
      00007B BF 06 02         [24]  682 	cjne	r7,#0x06,00130$
      00007E 80 19            [24]  683 	sjmp	00104$
      000080                        684 00130$:
      000080 BF 07 02         [24]  685 	cjne	r7,#0x07,00131$
      000083 80 18            [24]  686 	sjmp	00105$
      000085                        687 00131$:
      000085 BF 08 02         [24]  688 	cjne	r7,#0x08,00132$
      000088 80 07            [24]  689 	sjmp	00102$
      00008A                        690 00132$:
      00008A BF 09 13         [24]  691 	cjne	r7,#0x09,00107$
                                    692 ;	main.c:147: case(STEER_N90):angle = 1; break;
      00008D 75*06 01         [24]  693 	mov	_angle,#0x01
                                    694 ;	main.c:149: case(STEER_N45):angle = 2; break;
      000090 22               [24]  695 	ret
      000091                        696 00102$:
      000091 75*06 02         [24]  697 	mov	_angle,#0x02
                                    698 ;	main.c:151: case(STEER_S):angle = 3; break;
      000094 22               [24]  699 	ret
      000095                        700 00103$:
      000095 75*06 03         [24]  701 	mov	_angle,#0x03
                                    702 ;	main.c:153: case(STEER_P45):angle = 4; break;
      000098 22               [24]  703 	ret
      000099                        704 00104$:
      000099 75*06 04         [24]  705 	mov	_angle,#0x04
                                    706 ;	main.c:155: case(STEER_P90):angle = 5; break;
      00009C 22               [24]  707 	ret
      00009D                        708 00105$:
      00009D 75*06 05         [24]  709 	mov	_angle,#0x05
                                    710 ;	main.c:156: }	
      0000A0                        711 00107$:
                                    712 ;	main.c:157: }
      0000A0 22               [24]  713 	ret
                                    714 ;------------------------------------------------------------
                                    715 ;Allocation info for local variables in function 'steerTurn'
                                    716 ;------------------------------------------------------------
                                    717 ;a                         Allocated to registers r6 
                                    718 ;------------------------------------------------------------
                                    719 ;	main.c:160: void steerTurn() {
                                    720 ;	-----------------------------------------
                                    721 ;	 function steerTurn
                                    722 ;	-----------------------------------------
      0000A1                        723 _steerTurn:
                                    724 ;	main.c:163: t0InterruptTimes++;
      0000A1 05*02            [12]  725 	inc	_t0InterruptTimes
      0000A3 E4               [12]  726 	clr	a
      0000A4 B5*02 02         [24]  727 	cjne	a,_t0InterruptTimes,00116$
      0000A7 05*03            [12]  728 	inc	(_t0InterruptTimes + 1)
      0000A9                        729 00116$:
                                    730 ;	main.c:164: a = t0InterruptTimes % 5;
      0000A9 75*00 05         [24]  731 	mov	__moduint_PARM_2,#0x05
      0000AC 75*01 00         [24]  732 	mov	(__moduint_PARM_2 + 1),#0x00
      0000AF 85*02 82         [24]  733 	mov	dpl,_t0InterruptTimes
      0000B2 85*03 83         [24]  734 	mov	dph,(_t0InterruptTimes + 1)
      0000B5 12r00r00         [24]  735 	lcall	__moduint
      0000B8 AE 82            [24]  736 	mov	r6,dpl
      0000BA AF 83            [24]  737 	mov	r7,dph
                                    738 ;	main.c:165: if (t0InterruptTimes == 200) {	//舵机转动到指定角度后,停止定时器0计时,时间太短的话，舵机左右转动是无法到指定位置的。
      0000BC 74 C8            [12]  739 	mov	a,#0xc8
      0000BE B5*02 06         [24]  740 	cjne	a,_t0InterruptTimes,00117$
      0000C1 E4               [12]  741 	clr	a
      0000C2 B5*03 02         [24]  742 	cjne	a,(_t0InterruptTimes + 1),00117$
      0000C5 80 02            [24]  743 	sjmp	00118$
      0000C7                        744 00117$:
      0000C7 80 09            [24]  745 	sjmp	00102$
      0000C9                        746 00118$:
                                    747 ;	main.c:166: t0InterruptTimes = 0;
      0000C9 E4               [12]  748 	clr	a
      0000CA F5*02            [12]  749 	mov	_t0InterruptTimes,a
      0000CC F5*03            [12]  750 	mov	(_t0InterruptTimes + 1),a
                                    751 ;	main.c:167: STEER_PWM = 0;	
                                    752 ;	assignBit
      0000CE C2 B2            [12]  753 	clr	_P3_2
                                    754 ;	main.c:168: TR0 = 0;
                                    755 ;	assignBit
      0000D0 C2 8C            [12]  756 	clr	_TR0
      0000D2                        757 00102$:
                                    758 ;	main.c:171: if (a < angle) {
      0000D2 C3               [12]  759 	clr	c
      0000D3 EE               [12]  760 	mov	a,r6
      0000D4 95*06            [12]  761 	subb	a,_angle
      0000D6 50 03            [24]  762 	jnc	00104$
                                    763 ;	main.c:172: STEER_PWM = 1;
                                    764 ;	assignBit
      0000D8 D2 B2            [12]  765 	setb	_P3_2
      0000DA 22               [24]  766 	ret
      0000DB                        767 00104$:
                                    768 ;	main.c:174: STEER_PWM = 0;
                                    769 ;	assignBit
      0000DB C2 B2            [12]  770 	clr	_P3_2
                                    771 ;	main.c:176: }
      0000DD 22               [24]  772 	ret
                                    773 ;------------------------------------------------------------
                                    774 ;Allocation info for local variables in function 'workSR04'
                                    775 ;------------------------------------------------------------
                                    776 ;	main.c:179: void workSR04() {
                                    777 ;	-----------------------------------------
                                    778 ;	 function workSR04
                                    779 ;	-----------------------------------------
      0000DE                        780 _workSR04:
                                    781 ;	main.c:181: TRIG = 1;
                                    782 ;	assignBit
      0000DE D2 B5            [12]  783 	setb	_P3_5
                                    784 ;	main.c:183: __nop; __nop; __nop; __nop; __nop;
      0000E0 00               [12]  785 	nop	
      0000E1 00               [12]  786 	nop	
      0000E2 00               [12]  787 	nop	
      0000E3 00               [12]  788 	nop	
      0000E4 00               [12]  789 	nop	
                                    790 ;	main.c:184: __nop; __nop; __nop; __nop; __nop;
      0000E5 00               [12]  791 	nop	
      0000E6 00               [12]  792 	nop	
      0000E7 00               [12]  793 	nop	
      0000E8 00               [12]  794 	nop	
      0000E9 00               [12]  795 	nop	
                                    796 ;	main.c:185: __nop; __nop; __nop; __nop; __nop;
      0000EA 00               [12]  797 	nop	
      0000EB 00               [12]  798 	nop	
      0000EC 00               [12]  799 	nop	
      0000ED 00               [12]  800 	nop	
      0000EE 00               [12]  801 	nop	
                                    802 ;	main.c:186: __nop; __nop; __nop; __nop; __nop;
      0000EF 00               [12]  803 	nop	
      0000F0 00               [12]  804 	nop	
      0000F1 00               [12]  805 	nop	
      0000F2 00               [12]  806 	nop	
      0000F3 00               [12]  807 	nop	
                                    808 ;	main.c:187: TRIG = 0;
                                    809 ;	assignBit
      0000F4 C2 B5            [12]  810 	clr	_P3_5
                                    811 ;	main.c:188: while(!ECHO);
      0000F6                        812 00101$:
      0000F6 30 B4 FD         [24]  813 	jnb	_P3_4,00101$
                                    814 ;	main.c:189: TR0 = 1;
                                    815 ;	assignBit
      0000F9 D2 8C            [12]  816 	setb	_TR0
                                    817 ;	main.c:190: while(ECHO);
      0000FB                        818 00104$:
      0000FB 20 B4 FD         [24]  819 	jb	_P3_4,00104$
                                    820 ;	main.c:191: TR0 = 0;
                                    821 ;	assignBit
      0000FE C2 8C            [12]  822 	clr	_TR0
                                    823 ;	main.c:192: }
      000100 22               [24]  824 	ret
                                    825 ;------------------------------------------------------------
                                    826 ;Allocation info for local variables in function 'calculate'
                                    827 ;------------------------------------------------------------
                                    828 ;distance                  Allocated to registers r6 r7 
                                    829 ;time                      Allocated to registers 
                                    830 ;------------------------------------------------------------
                                    831 ;	main.c:195: int calculate() {
                                    832 ;	-----------------------------------------
                                    833 ;	 function calculate
                                    834 ;	-----------------------------------------
      000101                        835 _calculate:
                                    836 ;	main.c:199: time = TH0 * 256 + TL0;
      000101 AF 8C            [24]  837 	mov	r7,_TH0
      000103 7E 00            [12]  838 	mov	r6,#0x00
      000105 AC 8A            [24]  839 	mov	r4,_TL0
      000107 7D 00            [12]  840 	mov	r5,#0x00
      000109 EC               [12]  841 	mov	a,r4
      00010A 2E               [12]  842 	add	a,r6
      00010B F5 82            [12]  843 	mov	dpl,a
      00010D ED               [12]  844 	mov	a,r5
      00010E 3F               [12]  845 	addc	a,r7
      00010F F5 83            [12]  846 	mov	dph,a
                                    847 ;	main.c:201: TH0 = 0;
                                    848 ;	1-genFromRTrack replaced	mov	_TH0,#0x00
      000111 8E 8C            [24]  849 	mov	_TH0,r6
                                    850 ;	main.c:202: TL0 = 0;
                                    851 ;	1-genFromRTrack replaced	mov	_TL0,#0x00
      000113 8E 8A            [24]  852 	mov	_TL0,r6
                                    853 ;	main.c:203: time *= 1.085;
      000115 12r00r00         [24]  854 	lcall	___sint2fs
      000118 AC 82            [24]  855 	mov	r4,dpl
      00011A AD 83            [24]  856 	mov	r5,dph
      00011C AE F0            [24]  857 	mov	r6,b
      00011E FF               [12]  858 	mov	r7,a
      00011F C0 04            [24]  859 	push	ar4
      000121 C0 05            [24]  860 	push	ar5
      000123 C0 06            [24]  861 	push	ar6
      000125 C0 07            [24]  862 	push	ar7
      000127 90 E1 48         [24]  863 	mov	dptr,#0xe148
      00012A 75 F0 8A         [24]  864 	mov	b,#0x8a
      00012D 74 3F            [12]  865 	mov	a,#0x3f
      00012F 12r00r00         [24]  866 	lcall	___fsmul
      000132 AC 82            [24]  867 	mov	r4,dpl
      000134 AD 83            [24]  868 	mov	r5,dph
      000136 AE F0            [24]  869 	mov	r6,b
      000138 FF               [12]  870 	mov	r7,a
      000139 E5 81            [12]  871 	mov	a,sp
      00013B 24 FC            [12]  872 	add	a,#0xfc
      00013D F5 81            [12]  873 	mov	sp,a
      00013F 8C 82            [24]  874 	mov	dpl,r4
      000141 8D 83            [24]  875 	mov	dph,r5
      000143 8E F0            [24]  876 	mov	b,r6
      000145 EF               [12]  877 	mov	a,r7
      000146 12r00r00         [24]  878 	lcall	___fs2sint
                                    879 ;	main.c:206: distance = (time * 0.017); 
      000149 12r00r00         [24]  880 	lcall	___sint2fs
      00014C AC 82            [24]  881 	mov	r4,dpl
      00014E AD 83            [24]  882 	mov	r5,dph
      000150 AE F0            [24]  883 	mov	r6,b
      000152 FF               [12]  884 	mov	r7,a
      000153 C0 04            [24]  885 	push	ar4
      000155 C0 05            [24]  886 	push	ar5
      000157 C0 06            [24]  887 	push	ar6
      000159 C0 07            [24]  888 	push	ar7
      00015B 90 43 96         [24]  889 	mov	dptr,#0x4396
      00015E 75 F0 8B         [24]  890 	mov	b,#0x8b
      000161 74 3C            [12]  891 	mov	a,#0x3c
      000163 12r00r00         [24]  892 	lcall	___fsmul
      000166 AC 82            [24]  893 	mov	r4,dpl
      000168 AD 83            [24]  894 	mov	r5,dph
      00016A AE F0            [24]  895 	mov	r6,b
      00016C FF               [12]  896 	mov	r7,a
      00016D E5 81            [12]  897 	mov	a,sp
      00016F 24 FC            [12]  898 	add	a,#0xfc
      000171 F5 81            [12]  899 	mov	sp,a
      000173 8C 82            [24]  900 	mov	dpl,r4
      000175 8D 83            [24]  901 	mov	dph,r5
      000177 8E F0            [24]  902 	mov	b,r6
      000179 EF               [12]  903 	mov	a,r7
      00017A 12r00r00         [24]  904 	lcall	___fs2sint
      00017D AE 82            [24]  905 	mov	r6,dpl
      00017F AF 83            [24]  906 	mov	r7,dph
                                    907 ;	main.c:207: if(isOverStep) {
                                    908 ;	main.c:208: isOverStep = 0;
                                    909 ;	assignBit
      000181 10*00 02         [24]  910 	jbc	_isOverStep,00111$
      000184 80 07            [24]  911 	sjmp	00102$
      000186                        912 00111$:
                                    913 ;	main.c:209: SEG = 0xff;
      000186 75 A0 FF         [24]  914 	mov	_P2,#0xff
                                    915 ;	main.c:211: return -1;
      000189 90 FF FF         [24]  916 	mov	dptr,#0xffff
      00018C 22               [24]  917 	ret
      00018D                        918 00102$:
                                    919 ;	main.c:214: SEG = seg[distance];
      00018D EE               [12]  920 	mov	a,r6
      00018E 24r00            [12]  921 	add	a,#_seg
      000190 F5 82            [12]  922 	mov	dpl,a
      000192 EF               [12]  923 	mov	a,r7
      000193 34s00            [12]  924 	addc	a,#(_seg >> 8)
      000195 F5 83            [12]  925 	mov	dph,a
      000197 E4               [12]  926 	clr	a
      000198 93               [24]  927 	movc	a,@a+dptr
      000199 F5 A0            [12]  928 	mov	_P2,a
                                    929 ;	main.c:217: return distance;
      00019B 8E 82            [24]  930 	mov	dpl,r6
      00019D 8F 83            [24]  931 	mov	dph,r7
                                    932 ;	main.c:219: }
      00019F 22               [24]  933 	ret
                                    934 ;------------------------------------------------------------
                                    935 ;Allocation info for local variables in function 'isHaveObs'
                                    936 ;------------------------------------------------------------
                                    937 ;dir                       Allocated to registers r7 
                                    938 ;distance                  Allocated to registers r5 r7 
                                    939 ;------------------------------------------------------------
                                    940 ;	main.c:222: __bit isHaveObs(uchar dir) {
                                    941 ;	-----------------------------------------
                                    942 ;	 function isHaveObs
                                    943 ;	-----------------------------------------
      0001A0                        944 _isHaveObs:
      0001A0 AF 82            [24]  945 	mov	r7,dpl
                                    946 ;	main.c:225: __bit sensor_flag = 1;	//0表示存在障碍物
      0001A2 7E 01            [12]  947 	mov	r6,#0x01
                                    948 ;	main.c:226: switch(dir) {
      0001A4 BF 05 02         [24]  949 	cjne	r7,#0x05,00131$
      0001A7 80 0A            [24]  950 	sjmp	00101$
      0001A9                        951 00131$:
      0001A9 BF 06 02         [24]  952 	cjne	r7,#0x06,00132$
      0001AC 80 13            [24]  953 	sjmp	00103$
      0001AE                        954 00132$:
                                    955 ;	main.c:227: case(STEER_S):
      0001AE BF 08 15         [24]  956 	cjne	r7,#0x08,00104$
      0001B1 80 07            [24]  957 	sjmp	00102$
      0001B3                        958 00101$:
                                    959 ;	main.c:228: sensor_flag = FRONT_SENSER;
      0001B3 A2 94            [12]  960 	mov	c,_P1_4
      0001B5 E4               [12]  961 	clr	a
      0001B6 33               [12]  962 	rlc	a
      0001B7 FE               [12]  963 	mov	r6,a
                                    964 ;	main.c:229: break;
                                    965 ;	main.c:230: case(STEER_N45):
      0001B8 80 0C            [24]  966 	sjmp	00104$
      0001BA                        967 00102$:
                                    968 ;	main.c:231: sensor_flag = LEFT_SENSER;
      0001BA A2 96            [12]  969 	mov	c,_P1_6
      0001BC E4               [12]  970 	clr	a
      0001BD 33               [12]  971 	rlc	a
      0001BE FE               [12]  972 	mov	r6,a
                                    973 ;	main.c:232: break;
                                    974 ;	main.c:233: case(STEER_P45):
      0001BF 80 05            [24]  975 	sjmp	00104$
      0001C1                        976 00103$:
                                    977 ;	main.c:234: sensor_flag = RIGHT_SENSER;
      0001C1 A2 97            [12]  978 	mov	c,_P1_7
      0001C3 E4               [12]  979 	clr	a
      0001C4 33               [12]  980 	rlc	a
      0001C5 FE               [12]  981 	mov	r6,a
                                    982 ;	main.c:236: }
      0001C6                        983 00104$:
                                    984 ;	main.c:238: ET2 = 0;	//禁止定时器2中断，以免对舵机的PWM波形产生影响
                                    985 ;	assignBit
      0001C6 C2 AD            [12]  986 	clr	_ET2
                                    987 ;	main.c:239: setTurnAngle(dir);
      0001C8 8F 82            [24]  988 	mov	dpl,r7
      0001CA C0 06            [24]  989 	push	ar6
      0001CC 12r00r74         [24]  990 	lcall	_setTurnAngle
                                    991 ;	main.c:240: operate = STEER_OPERATE;
      0001CF 75*00 02         [24]  992 	mov	_operate,#0x02
                                    993 ;	main.c:241: initTimer0();
      0001D2 12r04r92         [24]  994 	lcall	_initTimer0
                                    995 ;	main.c:242: delay(5);		//不设延迟会导致舵机无法转动
      0001D5 90 00 05         [24]  996 	mov	dptr,#0x0005
      0001D8 12r00r00         [24]  997 	lcall	_delay
                                    998 ;	main.c:246: operate = SR04_OPERATE;
      0001DB 75*00 03         [24]  999 	mov	_operate,#0x03
                                   1000 ;	main.c:247: initTimer0();
      0001DE 12r04r92         [24] 1001 	lcall	_initTimer0
                                   1002 ;	main.c:248: workSR04();		//超声波模块工作
      0001E1 12r00rDE         [24] 1003 	lcall	_workSR04
                                   1004 ;	main.c:249: distance = calculate();
      0001E4 12r01r01         [24] 1005 	lcall	_calculate
      0001E7 AD 82            [24] 1006 	mov	r5,dpl
      0001E9 AF 83            [24] 1007 	mov	r7,dph
      0001EB D0 06            [24] 1008 	pop	ar6
                                   1009 ;	main.c:251: if ((distance > OBS_DIS | distance == -1) && sensor_flag == 1) {	//距离大于允许的距离或者超出测量范围，且对应传感器没有被触发，则算没有障碍物
      0001ED C3               [12] 1010 	clr	c
      0001EE 74 0F            [12] 1011 	mov	a,#0x0f
      0001F0 9D               [12] 1012 	subb	a,r5
      0001F1 74 80            [12] 1013 	mov	a,#(0x00 ^ 0x80)
      0001F3 8F F0            [24] 1014 	mov	b,r7
      0001F5 63 F0 80         [24] 1015 	xrl	b,#0x80
      0001F8 95 F0            [12] 1016 	subb	a,b
      0001FA E4               [12] 1017 	clr	a
      0001FB 33               [12] 1018 	rlc	a
      0001FC FC               [12] 1019 	mov	r4,a
      0001FD E4               [12] 1020 	clr	a
      0001FE BD FF 04         [24] 1021 	cjne	r5,#0xff,00134$
      000201 BF FF 01         [24] 1022 	cjne	r7,#0xff,00134$
      000204 04               [12] 1023 	inc	a
      000205                       1024 00134$:
      000205 4C               [12] 1025 	orl	a,r4
      000206 60 05            [24] 1026 	jz	00106$
      000208 EE               [12] 1027 	mov	a,r6
      000209 60 02            [24] 1028 	jz	00106$
                                   1029 ;	main.c:252: return 0;
      00020B C3               [12] 1030 	clr	c
      00020C 22               [24] 1031 	ret
      00020D                       1032 00106$:
                                   1033 ;	main.c:254: return 1;
      00020D D3               [12] 1034 	setb	c
                                   1035 ;	main.c:256: }
      00020E 22               [24] 1036 	ret
                                   1037 ;------------------------------------------------------------
                                   1038 ;Allocation info for local variables in function 'selfControl'
                                   1039 ;------------------------------------------------------------
                                   1040 ;sensor_state              Allocated to registers r7 
                                   1041 ;a                         Allocated to registers r6 
                                   1042 ;------------------------------------------------------------
                                   1043 ;	main.c:260: void selfControl() {
                                   1044 ;	-----------------------------------------
                                   1045 ;	 function selfControl
                                   1046 ;	-----------------------------------------
      00020F                       1047 _selfControl:
                                   1048 ;	main.c:262: uchar sensor_state = 0xf0 & P1;		//获取传感器的情况，屏蔽P1低4位
      00020F E5 90            [12] 1049 	mov	a,_P1
      000211 54 F0            [12] 1050 	anl	a,#0xf0
      000213 FF               [12] 1051 	mov	r7,a
                                   1052 ;	main.c:263: uchar a = 0;
      000214 7E 00            [12] 1053 	mov	r6,#0x00
                                   1054 ;	main.c:264: switch(sensor_state) {
      000216 BF 20 02         [24] 1055 	cjne	r7,#0x20,00292$
      000219 80 2D            [24] 1056 	sjmp	00101$
      00021B                       1057 00292$:
      00021B BF 30 03         [24] 1058 	cjne	r7,#0x30,00293$
      00021E 02r02rA9         [24] 1059 	ljmp	00113$
      000221                       1060 00293$:
      000221 BF 60 03         [24] 1061 	cjne	r7,#0x60,00294$
      000224 02r03r28         [24] 1062 	ljmp	00130$
      000227                       1063 00294$:
      000227 BF 70 03         [24] 1064 	cjne	r7,#0x70,00295$
      00022A 02r04r04         [24] 1065 	ljmp	00152$
      00022D                       1066 00295$:
      00022D BF A0 03         [24] 1067 	cjne	r7,#0xa0,00296$
      000230 02r03r7E         [24] 1068 	ljmp	00139$
      000233                       1069 00296$:
      000233 BF B0 03         [24] 1070 	cjne	r7,#0xb0,00297$
      000236 02r03rD4         [24] 1071 	ljmp	00148$
      000239                       1072 00297$:
      000239 BF D0 03         [24] 1073 	cjne	r7,#0xd0,00298$
      00023C 02r03r1F         [24] 1074 	ljmp	00127$
      00023F                       1075 00298$:
      00023F BF E0 03         [24] 1076 	cjne	r7,#0xe0,00299$
      000242 02r02rF7         [24] 1077 	ljmp	00122$
      000245                       1078 00299$:
      000245 02r04r34         [24] 1079 	ljmp	00156$
                                   1080 ;	main.c:265: case(0x20):	//前左右
      000248                       1081 00101$:
                                   1082 ;	main.c:267: setObsFlag(1, 0, 1, 1);
                                   1083 ;	assignBit
      000248 D2*06            [12] 1084 	setb	_setObsFlag_PARM_1
                                   1085 ;	assignBit
      00024A C2*07            [12] 1086 	clr	_setObsFlag_PARM_2
                                   1087 ;	assignBit
      00024C D2*08            [12] 1088 	setb	_setObsFlag_PARM_3
                                   1089 ;	assignBit
      00024E D2*09            [12] 1090 	setb	_setObsFlag_PARM_4
      000250 C0 06            [24] 1091 	push	ar6
      000252 12r00r3D         [24] 1092 	lcall	_setObsFlag
      000255 D0 06            [24] 1093 	pop	ar6
                                   1094 ;	main.c:268: while(lObsFlag & rObsFlag & fObsFlag) {
      000257                       1095 00110$:
      000257 A2*04            [12] 1096 	mov	c,_lObsFlag
      000259 82*05            [24] 1097 	anl	c,_rObsFlag
      00025B 82*02            [24] 1098 	anl	c,_fObsFlag
      00025D 40 01            [24] 1099 	jc	00300$
      00025F 22               [24] 1100 	ret
      000260                       1101 00300$:
                                   1102 ;	main.c:269: CAR = BACK;
      000260 75 80 AA         [24] 1103 	mov	_P0,#0xaa
                                   1104 ;	main.c:271: CAR = STOP;
      000263 75 80 00         [24] 1105 	mov	_P0,#0x00
                                   1106 ;	main.c:272: if (a == 0) {
      000266 EE               [12] 1107 	mov	a,r6
      000267 70 0E            [24] 1108 	jnz	00106$
                                   1109 ;	main.c:273: lObsFlag = isHaveObs(STEER_N45);
      000269 75 82 08         [24] 1110 	mov	dpl,#0x08
      00026C C0 06            [24] 1111 	push	ar6
      00026E 12r01rA0         [24] 1112 	lcall	_isHaveObs
      000271 92*04            [24] 1113 	mov	_lObsFlag,c
      000273 D0 06            [24] 1114 	pop	ar6
      000275 80 1D            [24] 1115 	sjmp	00107$
      000277                       1116 00106$:
                                   1117 ;	main.c:274: } else if (a == 1) {
      000277 BE 01 0E         [24] 1118 	cjne	r6,#0x01,00103$
                                   1119 ;	main.c:275: fObsFlag = isHaveObs(STEER_S);
      00027A 75 82 05         [24] 1120 	mov	dpl,#0x05
      00027D C0 06            [24] 1121 	push	ar6
      00027F 12r01rA0         [24] 1122 	lcall	_isHaveObs
      000282 92*02            [24] 1123 	mov	_fObsFlag,c
      000284 D0 06            [24] 1124 	pop	ar6
      000286 80 0C            [24] 1125 	sjmp	00107$
      000288                       1126 00103$:
                                   1127 ;	main.c:277: rObsFlag = isHaveObs(STEER_P45);
      000288 75 82 06         [24] 1128 	mov	dpl,#0x06
      00028B C0 06            [24] 1129 	push	ar6
      00028D 12r01rA0         [24] 1130 	lcall	_isHaveObs
      000290 92*05            [24] 1131 	mov	_rObsFlag,c
      000292 D0 06            [24] 1132 	pop	ar6
      000294                       1133 00107$:
                                   1134 ;	main.c:279: CAR = BACK;
      000294 75 80 AA         [24] 1135 	mov	_P0,#0xaa
                                   1136 ;	main.c:280: delay(25);
      000297 90 00 19         [24] 1137 	mov	dptr,#0x0019
      00029A C0 06            [24] 1138 	push	ar6
      00029C 12r00r00         [24] 1139 	lcall	_delay
      00029F D0 06            [24] 1140 	pop	ar6
                                   1141 ;	main.c:281: a++;
      0002A1 0E               [12] 1142 	inc	r6
                                   1143 ;	main.c:282: if (a == 3) {
      0002A2 BE 03 B2         [24] 1144 	cjne	r6,#0x03,00110$
                                   1145 ;	main.c:283: a = 0;
      0002A5 7E 00            [12] 1146 	mov	r6,#0x00
                                   1147 ;	main.c:287: case(0x30):	//左右
      0002A7 80 AE            [24] 1148 	sjmp	00110$
      0002A9                       1149 00113$:
                                   1150 ;	main.c:289: setObsFlag(0, 0, 1, 1);
                                   1151 ;	assignBit
      0002A9 C2*06            [12] 1152 	clr	_setObsFlag_PARM_1
                                   1153 ;	assignBit
      0002AB C2*07            [12] 1154 	clr	_setObsFlag_PARM_2
                                   1155 ;	assignBit
      0002AD D2*08            [12] 1156 	setb	_setObsFlag_PARM_3
                                   1157 ;	assignBit
      0002AF D2*09            [12] 1158 	setb	_setObsFlag_PARM_4
      0002B1 C0 06            [24] 1159 	push	ar6
      0002B3 12r00r3D         [24] 1160 	lcall	_setObsFlag
      0002B6 D0 06            [24] 1161 	pop	ar6
                                   1162 ;	main.c:290: while(rObsFlag & fObsFlag) {
      0002B8                       1163 00119$:
      0002B8 A2*05            [12] 1164 	mov	c,_rObsFlag
      0002BA 82*02            [24] 1165 	anl	c,_fObsFlag
      0002BC 40 01            [24] 1166 	jc	00306$
      0002BE 22               [24] 1167 	ret
      0002BF                       1168 00306$:
                                   1169 ;	main.c:291: CAR = BACK;
      0002BF 75 80 AA         [24] 1170 	mov	_P0,#0xaa
                                   1171 ;	main.c:292: CAR = STOP;
      0002C2 75 80 00         [24] 1172 	mov	_P0,#0x00
                                   1173 ;	main.c:293: if (a == 0) {
      0002C5 EE               [12] 1174 	mov	a,r6
      0002C6 70 0E            [24] 1175 	jnz	00115$
                                   1176 ;	main.c:294: lObsFlag = isHaveObs(STEER_N45);
      0002C8 75 82 08         [24] 1177 	mov	dpl,#0x08
      0002CB C0 06            [24] 1178 	push	ar6
      0002CD 12r01rA0         [24] 1179 	lcall	_isHaveObs
      0002D0 92*04            [24] 1180 	mov	_lObsFlag,c
      0002D2 D0 06            [24] 1181 	pop	ar6
      0002D4 80 0C            [24] 1182 	sjmp	00116$
      0002D6                       1183 00115$:
                                   1184 ;	main.c:296: rObsFlag = isHaveObs(STEER_P45);
      0002D6 75 82 06         [24] 1185 	mov	dpl,#0x06
      0002D9 C0 06            [24] 1186 	push	ar6
      0002DB 12r01rA0         [24] 1187 	lcall	_isHaveObs
      0002DE 92*05            [24] 1188 	mov	_rObsFlag,c
      0002E0 D0 06            [24] 1189 	pop	ar6
      0002E2                       1190 00116$:
                                   1191 ;	main.c:298: CAR = BACK;
      0002E2 75 80 AA         [24] 1192 	mov	_P0,#0xaa
                                   1193 ;	main.c:299: delay(25);
      0002E5 90 00 19         [24] 1194 	mov	dptr,#0x0019
      0002E8 C0 06            [24] 1195 	push	ar6
      0002EA 12r00r00         [24] 1196 	lcall	_delay
      0002ED D0 06            [24] 1197 	pop	ar6
                                   1198 ;	main.c:300: a++;
      0002EF 0E               [12] 1199 	inc	r6
                                   1200 ;	main.c:301: if (a == 2) {
      0002F0 BE 02 C5         [24] 1201 	cjne	r6,#0x02,00119$
                                   1202 ;	main.c:302: a = 0;
      0002F3 7E 00            [12] 1203 	mov	r6,#0x00
                                   1204 ;	main.c:306: case(0xe0): //只有前
      0002F5 80 C1            [24] 1205 	sjmp	00119$
      0002F7                       1206 00122$:
                                   1207 ;	main.c:308: setObsFlag(1, 0, 0, 0);
                                   1208 ;	assignBit
      0002F7 D2*06            [12] 1209 	setb	_setObsFlag_PARM_1
                                   1210 ;	assignBit
      0002F9 C2*07            [12] 1211 	clr	_setObsFlag_PARM_2
                                   1212 ;	assignBit
      0002FB C2*08            [12] 1213 	clr	_setObsFlag_PARM_3
                                   1214 ;	assignBit
      0002FD C2*09            [12] 1215 	clr	_setObsFlag_PARM_4
      0002FF 12r00r3D         [24] 1216 	lcall	_setObsFlag
                                   1217 ;	main.c:309: while(fObsFlag) {
      000302                       1218 00123$:
      000302 20*02 01         [24] 1219 	jb	_fObsFlag,00310$
      000305 22               [24] 1220 	ret
      000306                       1221 00310$:
                                   1222 ;	main.c:310: CAR = BACK;
      000306 75 80 AA         [24] 1223 	mov	_P0,#0xaa
                                   1224 ;	main.c:311: CAR = STOP;
      000309 75 80 00         [24] 1225 	mov	_P0,#0x00
                                   1226 ;	main.c:312: fObsFlag = isHaveObs(STEER_S);
      00030C 75 82 05         [24] 1227 	mov	dpl,#0x05
      00030F 12r01rA0         [24] 1228 	lcall	_isHaveObs
      000312 92*02            [24] 1229 	mov	_fObsFlag,c
                                   1230 ;	main.c:313: CAR = BACK;
      000314 75 80 AA         [24] 1231 	mov	_P0,#0xaa
                                   1232 ;	main.c:314: delay(25);
      000317 90 00 19         [24] 1233 	mov	dptr,#0x0019
      00031A 12r00r00         [24] 1234 	lcall	_delay
                                   1235 ;	main.c:318: while(!BACK_SENSER) {
      00031D 80 E3            [24] 1236 	sjmp	00123$
      00031F                       1237 00127$:
      00031F 30 95 01         [24] 1238 	jnb	_P1_5,00311$
      000322 22               [24] 1239 	ret
      000323                       1240 00311$:
                                   1241 ;	main.c:319: CAR = FRONT;
      000323 75 80 55         [24] 1242 	mov	_P0,#0x55
                                   1243 ;	main.c:322: case(0x60): //右前
      000326 80 F7            [24] 1244 	sjmp	00127$
      000328                       1245 00130$:
                                   1246 ;	main.c:324: setObsFlag(1, 0, 0, 1);
                                   1247 ;	assignBit
      000328 D2*06            [12] 1248 	setb	_setObsFlag_PARM_1
                                   1249 ;	assignBit
      00032A C2*07            [12] 1250 	clr	_setObsFlag_PARM_2
                                   1251 ;	assignBit
      00032C C2*08            [12] 1252 	clr	_setObsFlag_PARM_3
                                   1253 ;	assignBit
      00032E D2*09            [12] 1254 	setb	_setObsFlag_PARM_4
      000330 C0 06            [24] 1255 	push	ar6
      000332 12r00r3D         [24] 1256 	lcall	_setObsFlag
      000335 D0 06            [24] 1257 	pop	ar6
                                   1258 ;	main.c:325: while(rObsFlag & fObsFlag) {
      000337                       1259 00136$:
      000337 A2*05            [12] 1260 	mov	c,_rObsFlag
      000339 82*02            [24] 1261 	anl	c,_fObsFlag
      00033B 50 38            [24] 1262 	jnc	00138$
                                   1263 ;	main.c:326: CAR = BACK;
      00033D 75 80 AA         [24] 1264 	mov	_P0,#0xaa
                                   1265 ;	main.c:328: CAR = STOP;
      000340 75 80 00         [24] 1266 	mov	_P0,#0x00
                                   1267 ;	main.c:329: if (a == 0) {
      000343 EE               [12] 1268 	mov	a,r6
      000344 70 0E            [24] 1269 	jnz	00132$
                                   1270 ;	main.c:330: rObsFlag = isHaveObs(STEER_P45);
      000346 75 82 06         [24] 1271 	mov	dpl,#0x06
      000349 C0 06            [24] 1272 	push	ar6
      00034B 12r01rA0         [24] 1273 	lcall	_isHaveObs
      00034E 92*05            [24] 1274 	mov	_rObsFlag,c
      000350 D0 06            [24] 1275 	pop	ar6
      000352 80 0C            [24] 1276 	sjmp	00133$
      000354                       1277 00132$:
                                   1278 ;	main.c:332: fObsFlag = isHaveObs(STEER_S);
      000354 75 82 05         [24] 1279 	mov	dpl,#0x05
      000357 C0 06            [24] 1280 	push	ar6
      000359 12r01rA0         [24] 1281 	lcall	_isHaveObs
      00035C 92*02            [24] 1282 	mov	_fObsFlag,c
      00035E D0 06            [24] 1283 	pop	ar6
      000360                       1284 00133$:
                                   1285 ;	main.c:334: CAR = BACK;
      000360 75 80 AA         [24] 1286 	mov	_P0,#0xaa
                                   1287 ;	main.c:335: delay(25);
      000363 90 00 19         [24] 1288 	mov	dptr,#0x0019
      000366 C0 06            [24] 1289 	push	ar6
      000368 12r00r00         [24] 1290 	lcall	_delay
      00036B D0 06            [24] 1291 	pop	ar6
                                   1292 ;	main.c:336: a++;
      00036D 0E               [12] 1293 	inc	r6
                                   1294 ;	main.c:337: if (a == 2) {
      00036E BE 02 C6         [24] 1295 	cjne	r6,#0x02,00136$
                                   1296 ;	main.c:338: a = 0;
      000371 7E 00            [12] 1297 	mov	r6,#0x00
      000373 80 C2            [24] 1298 	sjmp	00136$
      000375                       1299 00138$:
                                   1300 ;	main.c:341: CAR = FRONT_LEFT;
      000375 75 80 5A         [24] 1301 	mov	_P0,#0x5a
                                   1302 ;	main.c:342: delay(100);	
      000378 90 00 64         [24] 1303 	mov	dptr,#0x0064
                                   1304 ;	main.c:343: break;
      00037B 02r00r00         [24] 1305 	ljmp	_delay
                                   1306 ;	main.c:344: case(0xa0): //左前
      00037E                       1307 00139$:
                                   1308 ;	main.c:346: setObsFlag(1, 0, 1, 0);
                                   1309 ;	assignBit
      00037E D2*06            [12] 1310 	setb	_setObsFlag_PARM_1
                                   1311 ;	assignBit
      000380 C2*07            [12] 1312 	clr	_setObsFlag_PARM_2
                                   1313 ;	assignBit
      000382 D2*08            [12] 1314 	setb	_setObsFlag_PARM_3
                                   1315 ;	assignBit
      000384 C2*09            [12] 1316 	clr	_setObsFlag_PARM_4
      000386 C0 06            [24] 1317 	push	ar6
      000388 12r00r3D         [24] 1318 	lcall	_setObsFlag
      00038B D0 06            [24] 1319 	pop	ar6
                                   1320 ;	main.c:347: while(lObsFlag & fObsFlag) {
      00038D                       1321 00145$:
      00038D A2*04            [12] 1322 	mov	c,_lObsFlag
      00038F 82*02            [24] 1323 	anl	c,_fObsFlag
      000391 50 38            [24] 1324 	jnc	00147$
                                   1325 ;	main.c:348: CAR = BACK;
      000393 75 80 AA         [24] 1326 	mov	_P0,#0xaa
                                   1327 ;	main.c:349: CAR = STOP;
      000396 75 80 00         [24] 1328 	mov	_P0,#0x00
                                   1329 ;	main.c:350: if (a == 0) {
      000399 EE               [12] 1330 	mov	a,r6
      00039A 70 0E            [24] 1331 	jnz	00141$
                                   1332 ;	main.c:351: lObsFlag = isHaveObs(STEER_N45);
      00039C 75 82 08         [24] 1333 	mov	dpl,#0x08
      00039F C0 06            [24] 1334 	push	ar6
      0003A1 12r01rA0         [24] 1335 	lcall	_isHaveObs
      0003A4 92*04            [24] 1336 	mov	_lObsFlag,c
      0003A6 D0 06            [24] 1337 	pop	ar6
      0003A8 80 0C            [24] 1338 	sjmp	00142$
      0003AA                       1339 00141$:
                                   1340 ;	main.c:353: fObsFlag = isHaveObs(STEER_S);
      0003AA 75 82 05         [24] 1341 	mov	dpl,#0x05
      0003AD C0 06            [24] 1342 	push	ar6
      0003AF 12r01rA0         [24] 1343 	lcall	_isHaveObs
      0003B2 92*02            [24] 1344 	mov	_fObsFlag,c
      0003B4 D0 06            [24] 1345 	pop	ar6
      0003B6                       1346 00142$:
                                   1347 ;	main.c:355: CAR = BACK;
      0003B6 75 80 AA         [24] 1348 	mov	_P0,#0xaa
                                   1349 ;	main.c:356: delay(25);
      0003B9 90 00 19         [24] 1350 	mov	dptr,#0x0019
      0003BC C0 06            [24] 1351 	push	ar6
      0003BE 12r00r00         [24] 1352 	lcall	_delay
      0003C1 D0 06            [24] 1353 	pop	ar6
                                   1354 ;	main.c:357: a++;
      0003C3 0E               [12] 1355 	inc	r6
                                   1356 ;	main.c:358: if (a == 2) {
      0003C4 BE 02 C6         [24] 1357 	cjne	r6,#0x02,00145$
                                   1358 ;	main.c:359: a = 0;
      0003C7 7E 00            [12] 1359 	mov	r6,#0x00
      0003C9 80 C2            [24] 1360 	sjmp	00145$
      0003CB                       1361 00147$:
                                   1362 ;	main.c:362: CAR = FRONT_RIGHT;
      0003CB 75 80 A5         [24] 1363 	mov	_P0,#0xa5
                                   1364 ;	main.c:363: delay(100);
      0003CE 90 00 64         [24] 1365 	mov	dptr,#0x0064
                                   1366 ;	main.c:364: break;
                                   1367 ;	main.c:365: case(0xb0):	//只有左
      0003D1 02r00r00         [24] 1368 	ljmp	_delay
      0003D4                       1369 00148$:
                                   1370 ;	main.c:367: setObsFlag(0, 0, 1, 0);
                                   1371 ;	assignBit
      0003D4 C2*06            [12] 1372 	clr	_setObsFlag_PARM_1
                                   1373 ;	assignBit
      0003D6 C2*07            [12] 1374 	clr	_setObsFlag_PARM_2
                                   1375 ;	assignBit
      0003D8 D2*08            [12] 1376 	setb	_setObsFlag_PARM_3
                                   1377 ;	assignBit
      0003DA C2*09            [12] 1378 	clr	_setObsFlag_PARM_4
      0003DC 12r00r3D         [24] 1379 	lcall	_setObsFlag
                                   1380 ;	main.c:368: while(lObsFlag) {
      0003DF                       1381 00149$:
      0003DF 30*04 19         [24] 1382 	jnb	_lObsFlag,00151$
                                   1383 ;	main.c:369: CAR = BACK;
      0003E2 75 80 AA         [24] 1384 	mov	_P0,#0xaa
                                   1385 ;	main.c:370: CAR = STOP;
      0003E5 75 80 00         [24] 1386 	mov	_P0,#0x00
                                   1387 ;	main.c:371: lObsFlag = isHaveObs(STEER_N45);
      0003E8 75 82 08         [24] 1388 	mov	dpl,#0x08
      0003EB 12r01rA0         [24] 1389 	lcall	_isHaveObs
      0003EE 92*04            [24] 1390 	mov	_lObsFlag,c
                                   1391 ;	main.c:372: CAR = BACK;
      0003F0 75 80 AA         [24] 1392 	mov	_P0,#0xaa
                                   1393 ;	main.c:373: delay(25);
      0003F3 90 00 19         [24] 1394 	mov	dptr,#0x0019
      0003F6 12r00r00         [24] 1395 	lcall	_delay
      0003F9 80 E4            [24] 1396 	sjmp	00149$
      0003FB                       1397 00151$:
                                   1398 ;	main.c:375: CAR = FRONT_RIGHT;
      0003FB 75 80 A5         [24] 1399 	mov	_P0,#0xa5
                                   1400 ;	main.c:376: delay(100);
      0003FE 90 00 64         [24] 1401 	mov	dptr,#0x0064
                                   1402 ;	main.c:377: break;
                                   1403 ;	main.c:378: case(0x70):	//只有右
      000401 02r00r00         [24] 1404 	ljmp	_delay
      000404                       1405 00152$:
                                   1406 ;	main.c:380: setObsFlag(0, 0, 0, 1);
                                   1407 ;	assignBit
      000404 C2*06            [12] 1408 	clr	_setObsFlag_PARM_1
                                   1409 ;	assignBit
      000406 C2*07            [12] 1410 	clr	_setObsFlag_PARM_2
                                   1411 ;	assignBit
      000408 C2*08            [12] 1412 	clr	_setObsFlag_PARM_3
                                   1413 ;	assignBit
      00040A D2*09            [12] 1414 	setb	_setObsFlag_PARM_4
      00040C 12r00r3D         [24] 1415 	lcall	_setObsFlag
                                   1416 ;	main.c:381: while(rObsFlag) {
      00040F                       1417 00153$:
      00040F 30*05 19         [24] 1418 	jnb	_rObsFlag,00155$
                                   1419 ;	main.c:382: CAR = BACK;
      000412 75 80 AA         [24] 1420 	mov	_P0,#0xaa
                                   1421 ;	main.c:383: CAR = STOP;
      000415 75 80 00         [24] 1422 	mov	_P0,#0x00
                                   1423 ;	main.c:384: rObsFlag = isHaveObs(STEER_P45);
      000418 75 82 06         [24] 1424 	mov	dpl,#0x06
      00041B 12r01rA0         [24] 1425 	lcall	_isHaveObs
      00041E 92*05            [24] 1426 	mov	_rObsFlag,c
                                   1427 ;	main.c:385: CAR = BACK;
      000420 75 80 AA         [24] 1428 	mov	_P0,#0xaa
                                   1429 ;	main.c:386: delay(25);
      000423 90 00 19         [24] 1430 	mov	dptr,#0x0019
      000426 12r00r00         [24] 1431 	lcall	_delay
      000429 80 E4            [24] 1432 	sjmp	00153$
      00042B                       1433 00155$:
                                   1434 ;	main.c:388: CAR = FRONT_LEFT;
      00042B 75 80 5A         [24] 1435 	mov	_P0,#0x5a
                                   1436 ;	main.c:389: delay(100);	
      00042E 90 00 64         [24] 1437 	mov	dptr,#0x0064
                                   1438 ;	main.c:390: break;
                                   1439 ;	main.c:391: default:
      000431 02r00r00         [24] 1440 	ljmp	_delay
      000434                       1441 00156$:
                                   1442 ;	main.c:392: CAR = STOP;
      000434 75 80 00         [24] 1443 	mov	_P0,#0x00
                                   1444 ;	main.c:394: }
                                   1445 ;	main.c:395: }
      000437 22               [24] 1446 	ret
                                   1447 ;------------------------------------------------------------
                                   1448 ;Allocation info for local variables in function 'btControl'
                                   1449 ;------------------------------------------------------------
                                   1450 ;cmd                       Allocated to registers r7 
                                   1451 ;------------------------------------------------------------
                                   1452 ;	main.c:398: void btControl(uchar cmd) {
                                   1453 ;	-----------------------------------------
                                   1454 ;	 function btControl
                                   1455 ;	-----------------------------------------
      000438                       1456 _btControl:
      000438 AF 82            [24] 1457 	mov	r7,dpl
                                   1458 ;	main.c:400: switch(cmd) {
      00043A BF 61 02         [24] 1459 	cjne	r7,#0x61,00152$
      00043D 80 32            [24] 1460 	sjmp	00106$
      00043F                       1461 00152$:
      00043F BF 62 02         [24] 1462 	cjne	r7,#0x62,00153$
      000442 80 1D            [24] 1463 	sjmp	00102$
      000444                       1464 00153$:
      000444 BF 64 02         [24] 1465 	cjne	r7,#0x64,00154$
      000447 80 31            [24] 1466 	sjmp	00109$
      000449                       1467 00154$:
      000449 BF 66 02         [24] 1468 	cjne	r7,#0x66,00155$
      00044C 80 0F            [24] 1469 	sjmp	00101$
      00044E                       1470 00155$:
      00044E BF 6C 02         [24] 1471 	cjne	r7,#0x6c,00156$
      000451 80 12            [24] 1472 	sjmp	00103$
      000453                       1473 00156$:
      000453 BF 72 02         [24] 1474 	cjne	r7,#0x72,00157$
      000456 80 11            [24] 1475 	sjmp	00104$
      000458                       1476 00157$:
                                   1477 ;	main.c:401: case('f'): CAR = FRONT; break;
      000458 BF 73 26         [24] 1478 	cjne	r7,#0x73,00112$
      00045B 80 10            [24] 1479 	sjmp	00105$
      00045D                       1480 00101$:
      00045D 75 80 55         [24] 1481 	mov	_P0,#0x55
                                   1482 ;	main.c:402: case('b'): CAR = BACK; break;
      000460 22               [24] 1483 	ret
      000461                       1484 00102$:
      000461 75 80 AA         [24] 1485 	mov	_P0,#0xaa
                                   1486 ;	main.c:403: case('l'): CAR = FRONT_LEFT; break;
      000464 22               [24] 1487 	ret
      000465                       1488 00103$:
      000465 75 80 5A         [24] 1489 	mov	_P0,#0x5a
                                   1490 ;	main.c:404: case('r'): CAR = FRONT_RIGHT; break;
      000468 22               [24] 1491 	ret
      000469                       1492 00104$:
      000469 75 80 A5         [24] 1493 	mov	_P0,#0xa5
                                   1494 ;	main.c:405: case('s'): CAR = STOP; break;
      00046C 22               [24] 1495 	ret
      00046D                       1496 00105$:
      00046D 75 80 00         [24] 1497 	mov	_P0,#0x00
                                   1498 ;	main.c:406: case('a'): 
      000470 22               [24] 1499 	ret
      000471                       1500 00106$:
                                   1501 ;	main.c:407: if (speed < M_PWM_CYCLE) {
      000471 74 F6            [12] 1502 	mov	a,#0x100 - 0x0a
      000473 25*01            [12] 1503 	add	a,_speed
      000475 40 0D            [24] 1504 	jc	00114$
                                   1505 ;	main.c:408: speed++;
      000477 05*01            [12] 1506 	inc	_speed
                                   1507 ;	main.c:410: break;
                                   1508 ;	main.c:411: case('d'): 
      000479 22               [24] 1509 	ret
      00047A                       1510 00109$:
                                   1511 ;	main.c:412: if (speed != 0) {
      00047A E5*01            [12] 1512 	mov	a,_speed
      00047C 60 06            [24] 1513 	jz	00114$
                                   1514 ;	main.c:413: speed--;
      00047E 15*01            [12] 1515 	dec	_speed
                                   1516 ;	main.c:415: break;
                                   1517 ;	main.c:416: default:CAR = STOP; break;
      000480 22               [24] 1518 	ret
      000481                       1519 00112$:
      000481 75 80 00         [24] 1520 	mov	_P0,#0x00
                                   1521 ;	main.c:417: }
      000484                       1522 00114$:
                                   1523 ;	main.c:418: }
      000484 22               [24] 1524 	ret
                                   1525 ;------------------------------------------------------------
                                   1526 ;Allocation info for local variables in function 'initInterrupt'
                                   1527 ;------------------------------------------------------------
                                   1528 ;	main.c:421: void initInterrupt() {
                                   1529 ;	-----------------------------------------
                                   1530 ;	 function initInterrupt
                                   1531 ;	-----------------------------------------
      000485                       1532 _initInterrupt:
                                   1533 ;	main.c:423: EA = 1;			//允许总中断
                                   1534 ;	assignBit
      000485 D2 AF            [12] 1535 	setb	_EA
                                   1536 ;	main.c:424: ES = 1;			//允许串行口中断
                                   1537 ;	assignBit
      000487 D2 AC            [12] 1538 	setb	_ES
                                   1539 ;	main.c:425: ET0 = 1;		//允许定时器0中断
                                   1540 ;	assignBit
      000489 D2 A9            [12] 1541 	setb	_ET0
                                   1542 ;	main.c:426: ET2 = 1;		//允许定时器2中断
                                   1543 ;	assignBit
      00048B D2 AD            [12] 1544 	setb	_ET2
                                   1545 ;	main.c:427: EX1 = 1;		//允许外部中断1中断
                                   1546 ;	assignBit
      00048D D2 AA            [12] 1547 	setb	_EX1
                                   1548 ;	main.c:428: IT1 = 1;		//低跳沿触发
                                   1549 ;	assignBit
      00048F D2 8A            [12] 1550 	setb	_IT1
                                   1551 ;	main.c:429: }
      000491 22               [24] 1552 	ret
                                   1553 ;------------------------------------------------------------
                                   1554 ;Allocation info for local variables in function 'initTimer0'
                                   1555 ;------------------------------------------------------------
                                   1556 ;	main.c:432: void initTimer0() {
                                   1557 ;	-----------------------------------------
                                   1558 ;	 function initTimer0
                                   1559 ;	-----------------------------------------
      000492                       1560 _initTimer0:
                                   1561 ;	main.c:434: TMOD |= 0x01;	//工作方式1
      000492 43 89 01         [24] 1562 	orl	_TMOD,#0x01
                                   1563 ;	main.c:435: if (operate == STEER_OPERATE) {	//为舵机转动
      000495 74 02            [12] 1564 	mov	a,#0x02
      000497 B5*00 09         [24] 1565 	cjne	a,_operate,00104$
                                   1566 ;	main.c:436: TH0 = 0xFE;		//中断时间0.5ms
      00049A 75 8C FE         [24] 1567 	mov	_TH0,#0xfe
                                   1568 ;	main.c:437: TL0 = 0x33;
      00049D 75 8A 33         [24] 1569 	mov	_TL0,#0x33
                                   1570 ;	main.c:438: TR0 = 1;	//开启定时器0
                                   1571 ;	assignBit
      0004A0 D2 8C            [12] 1572 	setb	_TR0
      0004A2 22               [24] 1573 	ret
      0004A3                       1574 00104$:
                                   1575 ;	main.c:439: }else if (operate == SR04_OPERATE) {		//为超声波
      0004A3 74 03            [12] 1576 	mov	a,#0x03
      0004A5 B5*00 06         [24] 1577 	cjne	a,_operate,00106$
                                   1578 ;	main.c:440: TH0 = 0;
      0004A8 75 8C 00         [24] 1579 	mov	_TH0,#0x00
                                   1580 ;	main.c:441: TL0 = 0;
      0004AB 75 8A 00         [24] 1581 	mov	_TL0,#0x00
      0004AE                       1582 00106$:
                                   1583 ;	main.c:443: }
      0004AE 22               [24] 1584 	ret
                                   1585 ;------------------------------------------------------------
                                   1586 ;Allocation info for local variables in function 'initSerial'
                                   1587 ;------------------------------------------------------------
                                   1588 ;	main.c:446: void initSerial() {
                                   1589 ;	-----------------------------------------
                                   1590 ;	 function initSerial
                                   1591 ;	-----------------------------------------
      0004AF                       1592 _initSerial:
                                   1593 ;	main.c:448: SCON = 0x50;	//串行口工作模式1
      0004AF 75 98 50         [24] 1594 	mov	_SCON,#0x50
                                   1595 ;	main.c:449: PCON = 0x00;
      0004B2 75 87 00         [24] 1596 	mov	_PCON,#0x00
                                   1597 ;	main.c:450: RI = 0;			//接受中断标志清零
                                   1598 ;	assignBit
      0004B5 C2 98            [12] 1599 	clr	_RI
                                   1600 ;	main.c:452: TMOD |= 0x20;	//定时器T1方式2 
      0004B7 43 89 20         [24] 1601 	orl	_TMOD,#0x20
                                   1602 ;	main.c:453: TL1 = 0xfd;
      0004BA 75 8B FD         [24] 1603 	mov	_TL1,#0xfd
                                   1604 ;	main.c:454: TH1 = 0xfd;
      0004BD 75 8D FD         [24] 1605 	mov	_TH1,#0xfd
                                   1606 ;	main.c:455: TR1 = 1;		//定时器开始计数
                                   1607 ;	assignBit
      0004C0 D2 8E            [12] 1608 	setb	_TR1
                                   1609 ;	main.c:456: }
      0004C2 22               [24] 1610 	ret
                                   1611 ;------------------------------------------------------------
                                   1612 ;Allocation info for local variables in function 'initTimer2'
                                   1613 ;------------------------------------------------------------
                                   1614 ;	main.c:460: void initTimer2() {
                                   1615 ;	-----------------------------------------
                                   1616 ;	 function initTimer2
                                   1617 ;	-----------------------------------------
      0004C3                       1618 _initTimer2:
                                   1619 ;	main.c:462: T2CON = 0x00;
      0004C3 75 C8 00         [24] 1620 	mov	_T2CON,#0x00
                                   1621 ;	main.c:463: T2MOD = 0x00;	
      0004C6 75 C9 00         [24] 1622 	mov	_T2MOD,#0x00
                                   1623 ;	main.c:464: TH2 = RCAP2H = 0xff;		//中断0.1ms
      0004C9 75 CB FF         [24] 1624 	mov	_RCAP2H,#0xff
      0004CC 75 CD FF         [24] 1625 	mov	_TH2,#0xff
                                   1626 ;	main.c:465: TL2 = RCAP2L = 0xa4;
      0004CF 75 CA A4         [24] 1627 	mov	_RCAP2L,#0xa4
      0004D2 75 CC A4         [24] 1628 	mov	_TL2,#0xa4
                                   1629 ;	main.c:466: TR2 = 1;	//开启定时器2
                                   1630 ;	assignBit
      0004D5 D2 CA            [12] 1631 	setb	_TR2
                                   1632 ;	main.c:467: }
      0004D7 22               [24] 1633 	ret
                                   1634 ;------------------------------------------------------------
                                   1635 ;Allocation info for local variables in function 'timer0'
                                   1636 ;------------------------------------------------------------
                                   1637 ;	main.c:469: void timer0() __interrupt 1 __using 0 {
                                   1638 ;	-----------------------------------------
                                   1639 ;	 function timer0
                                   1640 ;	-----------------------------------------
      0004D8                       1641 _timer0:
      0004D8 C0*00            [24] 1642 	push	bits
      0004DA C0 E0            [24] 1643 	push	acc
      0004DC C0 F0            [24] 1644 	push	b
      0004DE C0 82            [24] 1645 	push	dpl
      0004E0 C0 83            [24] 1646 	push	dph
      0004E2 C0 07            [24] 1647 	push	(0+7)
      0004E4 C0 06            [24] 1648 	push	(0+6)
      0004E6 C0 05            [24] 1649 	push	(0+5)
      0004E8 C0 04            [24] 1650 	push	(0+4)
      0004EA C0 03            [24] 1651 	push	(0+3)
      0004EC C0 02            [24] 1652 	push	(0+2)
      0004EE C0 01            [24] 1653 	push	(0+1)
      0004F0 C0 00            [24] 1654 	push	(0+0)
      0004F2 C0 D0            [24] 1655 	push	psw
      0004F4 75 D0 00         [24] 1656 	mov	psw,#0x00
                                   1657 ;	main.c:471: if (operate == STEER_OPERATE) {
      0004F7 74 02            [12] 1658 	mov	a,#0x02
      0004F9 B5*00 0B         [24] 1659 	cjne	a,_operate,00104$
                                   1660 ;	main.c:473: TH0 = 0xFE;		//中断时间0.5ms
      0004FC 75 8C FE         [24] 1661 	mov	_TH0,#0xfe
                                   1662 ;	main.c:474: TL0 = 0x33;
      0004FF 75 8A 33         [24] 1663 	mov	_TL0,#0x33
                                   1664 ;	main.c:475: steerTurn();
      000502 12r00rA1         [24] 1665 	lcall	_steerTurn
      000505 80 0D            [24] 1666 	sjmp	00106$
      000507                       1667 00104$:
                                   1668 ;	main.c:476: } else if (operate == SR04_OPERATE) {
      000507 74 03            [12] 1669 	mov	a,#0x03
      000509 B5*00 08         [24] 1670 	cjne	a,_operate,00106$
                                   1671 ;	main.c:477: TH0 = 0;
      00050C 75 8C 00         [24] 1672 	mov	_TH0,#0x00
                                   1673 ;	main.c:478: TL0 = 0;
      00050F 75 8A 00         [24] 1674 	mov	_TL0,#0x00
                                   1675 ;	main.c:479: isOverStep = 1;
                                   1676 ;	assignBit
      000512 D2*00            [12] 1677 	setb	_isOverStep
      000514                       1678 00106$:
                                   1679 ;	main.c:481: }
      000514 D0 D0            [24] 1680 	pop	psw
      000516 D0 00            [24] 1681 	pop	(0+0)
      000518 D0 01            [24] 1682 	pop	(0+1)
      00051A D0 02            [24] 1683 	pop	(0+2)
      00051C D0 03            [24] 1684 	pop	(0+3)
      00051E D0 04            [24] 1685 	pop	(0+4)
      000520 D0 05            [24] 1686 	pop	(0+5)
      000522 D0 06            [24] 1687 	pop	(0+6)
      000524 D0 07            [24] 1688 	pop	(0+7)
      000526 D0 83            [24] 1689 	pop	dph
      000528 D0 82            [24] 1690 	pop	dpl
      00052A D0 F0            [24] 1691 	pop	b
      00052C D0 E0            [24] 1692 	pop	acc
      00052E D0*00            [24] 1693 	pop	bits
      000530 32               [24] 1694 	reti
                                   1695 ;------------------------------------------------------------
                                   1696 ;Allocation info for local variables in function 'int1'
                                   1697 ;------------------------------------------------------------
                                   1698 ;	main.c:484: void int1() __interrupt 2 __using 1 {
                                   1699 ;	-----------------------------------------
                                   1700 ;	 function int1
                                   1701 ;	-----------------------------------------
      000531                       1702 _int1:
                           00000F  1703 	ar7 = 0x0f
                           00000E  1704 	ar6 = 0x0e
                           00000D  1705 	ar5 = 0x0d
                           00000C  1706 	ar4 = 0x0c
                           00000B  1707 	ar3 = 0x0b
                           00000A  1708 	ar2 = 0x0a
                           000009  1709 	ar1 = 0x09
                           000008  1710 	ar0 = 0x08
                                   1711 ;	main.c:485: operate = SELF_OPERATE;
      000531 75*00 04         [24] 1712 	mov	_operate,#0x04
                                   1713 ;	main.c:486: SWITCH_SELF_CONTROL = 1;	//置高电平为下一次低跳沿产生做准备
                                   1714 ;	assignBit
      000534 D2 90            [12] 1715 	setb	_P1_0
                                   1716 ;	main.c:487: }
      000536 32               [24] 1717 	reti
                                   1718 ;	eliminated unneeded mov psw,# (no regs used in bank)
                                   1719 ;	eliminated unneeded push/pop psw
                                   1720 ;	eliminated unneeded push/pop dpl
                                   1721 ;	eliminated unneeded push/pop dph
                                   1722 ;	eliminated unneeded push/pop b
                                   1723 ;	eliminated unneeded push/pop acc
                                   1724 ;------------------------------------------------------------
                                   1725 ;Allocation info for local variables in function 'serial'
                                   1726 ;------------------------------------------------------------
                                   1727 ;	main.c:490: void serial() __interrupt 4 __using 2 {
                                   1728 ;	-----------------------------------------
                                   1729 ;	 function serial
                                   1730 ;	-----------------------------------------
      000537                       1731 _serial:
                           000017  1732 	ar7 = 0x17
                           000016  1733 	ar6 = 0x16
                           000015  1734 	ar5 = 0x15
                           000014  1735 	ar4 = 0x14
                           000013  1736 	ar3 = 0x13
                           000012  1737 	ar2 = 0x12
                           000011  1738 	ar1 = 0x11
                           000010  1739 	ar0 = 0x10
      000537 C0 E0            [24] 1740 	push	acc
                                   1741 ;	main.c:491: RI = 0;		
                                   1742 ;	assignBit
      000539 C2 98            [12] 1743 	clr	_RI
                                   1744 ;	main.c:492: if (operate == NO_OPERATE) {
      00053B E5*00            [12] 1745 	mov	a,_operate
      00053D 70 03            [24] 1746 	jnz	00103$
                                   1747 ;	main.c:493: operate = BT_OPERATE;
      00053F 75*00 01         [24] 1748 	mov	_operate,#0x01
      000542                       1749 00103$:
                                   1750 ;	main.c:495: }
      000542 D0 E0            [24] 1751 	pop	acc
      000544 32               [24] 1752 	reti
                                   1753 ;	eliminated unneeded mov psw,# (no regs used in bank)
                                   1754 ;	eliminated unneeded push/pop psw
                                   1755 ;	eliminated unneeded push/pop dpl
                                   1756 ;	eliminated unneeded push/pop dph
                                   1757 ;	eliminated unneeded push/pop b
                                   1758 ;------------------------------------------------------------
                                   1759 ;Allocation info for local variables in function 'timer2'
                                   1760 ;------------------------------------------------------------
                                   1761 ;a                         Allocated to registers r6 
                                   1762 ;------------------------------------------------------------
                                   1763 ;	main.c:498: void timer2() __interrupt 5 __using 3 {
                                   1764 ;	-----------------------------------------
                                   1765 ;	 function timer2
                                   1766 ;	-----------------------------------------
      000545                       1767 _timer2:
                           00001F  1768 	ar7 = 0x1f
                           00001E  1769 	ar6 = 0x1e
                           00001D  1770 	ar5 = 0x1d
                           00001C  1771 	ar4 = 0x1c
                           00001B  1772 	ar3 = 0x1b
                           00001A  1773 	ar2 = 0x1a
                           000019  1774 	ar1 = 0x19
                           000018  1775 	ar0 = 0x18
      000545 C0*00            [24] 1776 	push	bits
      000547 C0 E0            [24] 1777 	push	acc
      000549 C0 F0            [24] 1778 	push	b
      00054B C0 82            [24] 1779 	push	dpl
      00054D C0 83            [24] 1780 	push	dph
      00054F C0 07            [24] 1781 	push	(0+7)
      000551 C0 06            [24] 1782 	push	(0+6)
      000553 C0 05            [24] 1783 	push	(0+5)
      000555 C0 04            [24] 1784 	push	(0+4)
      000557 C0 03            [24] 1785 	push	(0+3)
      000559 C0 02            [24] 1786 	push	(0+2)
      00055B C0 01            [24] 1787 	push	(0+1)
      00055D C0 00            [24] 1788 	push	(0+0)
      00055F C0 D0            [24] 1789 	push	psw
      000561 75 D0 18         [24] 1790 	mov	psw,#0x18
                                   1791 ;	main.c:501: t2InterruptTimes++;
      000564 05*04            [12] 1792 	inc	_t2InterruptTimes
      000566 E4               [12] 1793 	clr	a
      000567 B5*04 02         [24] 1794 	cjne	a,_t2InterruptTimes,00116$
      00056A 05*05            [12] 1795 	inc	(_t2InterruptTimes + 1)
      00056C                       1796 00116$:
                                   1797 ;	main.c:502: a = t2InterruptTimes % M_PWM_CYCLE;
      00056C 75*00 0A         [24] 1798 	mov	__moduint_PARM_2,#0x0a
      00056F 75*01 00         [24] 1799 	mov	(__moduint_PARM_2 + 1),#0x00
      000572 85*04 82         [24] 1800 	mov	dpl,_t2InterruptTimes
      000575 85*05 83         [24] 1801 	mov	dph,(_t2InterruptTimes + 1)
      000578 75 D0 00         [24] 1802 	mov	psw,#0x00
      00057B 12r00r00         [24] 1803 	lcall	__moduint
      00057E 75 D0 18         [24] 1804 	mov	psw,#0x18
      000581 AE 82            [24] 1805 	mov	r6,dpl
                                   1806 ;	main.c:503: if (t2InterruptTimes == CMD_TIME) {
      000583 74 90            [12] 1807 	mov	a,#0x90
      000585 B5*04 0E         [24] 1808 	cjne	a,_t2InterruptTimes,00102$
      000588 74 01            [12] 1809 	mov	a,#0x01
      00058A B5*05 09         [24] 1810 	cjne	a,(_t2InterruptTimes + 1),00102$
                                   1811 ;	main.c:504: t2InterruptTimes = 0;
      00058D E4               [12] 1812 	clr	a
      00058E F5*04            [12] 1813 	mov	_t2InterruptTimes,a
      000590 F5*05            [12] 1814 	mov	(_t2InterruptTimes + 1),a
                                   1815 ;	main.c:505: CAR = STOP;
                                   1816 ;	1-genFromRTrack replaced	mov	_P0,#0x00
      000592 F5 80            [12] 1817 	mov	_P0,a
                                   1818 ;	main.c:506: TR2 = 0;	//溢出400次，说明执行了蓝牙发送的指令40ms了，停止计数器2计数，停止执行指令，等待蓝牙发送新的指令
                                   1819 ;	assignBit
      000594 C2 CA            [12] 1820 	clr	_TR2
      000596                       1821 00102$:
                                   1822 ;	main.c:508: if (a <= speed) {
      000596 C3               [12] 1823 	clr	c
      000597 E5*01            [12] 1824 	mov	a,_speed
      000599 9E               [12] 1825 	subb	a,r6
      00059A 40 04            [24] 1826 	jc	00104$
                                   1827 ;	main.c:509: M_PWM = 1;
                                   1828 ;	assignBit
      00059C D2 B6            [12] 1829 	setb	_P3_6
      00059E 80 02            [24] 1830 	sjmp	00106$
      0005A0                       1831 00104$:
                                   1832 ;	main.c:511: M_PWM = 0;
                                   1833 ;	assignBit
      0005A0 C2 B6            [12] 1834 	clr	_P3_6
      0005A2                       1835 00106$:
                                   1836 ;	main.c:514: }
      0005A2 D0 D0            [24] 1837 	pop	psw
      0005A4 D0 00            [24] 1838 	pop	(0+0)
      0005A6 D0 01            [24] 1839 	pop	(0+1)
      0005A8 D0 02            [24] 1840 	pop	(0+2)
      0005AA D0 03            [24] 1841 	pop	(0+3)
      0005AC D0 04            [24] 1842 	pop	(0+4)
      0005AE D0 05            [24] 1843 	pop	(0+5)
      0005B0 D0 06            [24] 1844 	pop	(0+6)
      0005B2 D0 07            [24] 1845 	pop	(0+7)
      0005B4 D0 83            [24] 1846 	pop	dph
      0005B6 D0 82            [24] 1847 	pop	dpl
      0005B8 D0 F0            [24] 1848 	pop	b
      0005BA D0 E0            [24] 1849 	pop	acc
      0005BC D0*00            [24] 1850 	pop	bits
      0005BE 32               [24] 1851 	reti
                                   1852 ;------------------------------------------------------------
                                   1853 ;Allocation info for local variables in function 'setup'
                                   1854 ;------------------------------------------------------------
                                   1855 ;	main.c:517: void setup() {
                                   1856 ;	-----------------------------------------
                                   1857 ;	 function setup
                                   1858 ;	-----------------------------------------
      0005BF                       1859 _setup:
                           000007  1860 	ar7 = 0x07
                           000006  1861 	ar6 = 0x06
                           000005  1862 	ar5 = 0x05
                           000004  1863 	ar4 = 0x04
                           000003  1864 	ar3 = 0x03
                           000002  1865 	ar2 = 0x02
                           000001  1866 	ar1 = 0x01
                           000000  1867 	ar0 = 0x00
                                   1868 ;	main.c:518: initInterrupt();
      0005BF 12r04r85         [24] 1869 	lcall	_initInterrupt
                                   1870 ;	main.c:519: initSerial();
      0005C2 12r04rAF         [24] 1871 	lcall	_initSerial
                                   1872 ;	main.c:520: initTimer2();
      0005C5 12r04rC3         [24] 1873 	lcall	_initTimer2
                                   1874 ;	main.c:521: operate = NO_OPERATE;
      0005C8 75*00 00         [24] 1875 	mov	_operate,#0x00
                                   1876 ;	main.c:522: STBY = 1;
                                   1877 ;	assignBit
      0005CB D2 B7            [12] 1878 	setb	_P3_7
                                   1879 ;	main.c:523: }
      0005CD 22               [24] 1880 	ret
                                   1881 ;------------------------------------------------------------
                                   1882 ;Allocation info for local variables in function 'loop'
                                   1883 ;------------------------------------------------------------
                                   1884 ;	main.c:526: void loop() {
                                   1885 ;	-----------------------------------------
                                   1886 ;	 function loop
                                   1887 ;	-----------------------------------------
      0005CE                       1888 _loop:
                                   1889 ;	main.c:528: sensorTrigger();
      0005CE 12r00r2D         [24] 1890 	lcall	_sensorTrigger
                                   1891 ;	main.c:529: if (SWITCH_SELF_CONTROL) {
      0005D1 30 90 06         [24] 1892 	jnb	_P1_0,00102$
                                   1893 ;	main.c:530: ledStatus(0);	
      0005D4 75 82 00         [24] 1894 	mov	dpl,#0x00
      0005D7 12r00r4E         [24] 1895 	lcall	_ledStatus
      0005DA                       1896 00102$:
                                   1897 ;	main.c:532: if (operate == BT_OPERATE) {
      0005DA 74 01            [12] 1898 	mov	a,#0x01
      0005DC B5*00 0E         [24] 1899 	cjne	a,_operate,00106$
                                   1900 ;	main.c:533: ledStatus(2);
      0005DF 75 82 02         [24] 1901 	mov	dpl,#0x02
      0005E2 12r00r4E         [24] 1902 	lcall	_ledStatus
                                   1903 ;	main.c:534: btControl(SBUF);
      0005E5 85 99 82         [24] 1904 	mov	dpl,_SBUF
      0005E8 12r04r38         [24] 1905 	lcall	_btControl
      0005EB 80 14            [24] 1906 	sjmp	00107$
      0005ED                       1907 00106$:
                                   1908 ;	main.c:535: } else if (operate == SELF_OPERATE) {
      0005ED 74 04            [12] 1909 	mov	a,#0x04
      0005EF B5*00 0F         [24] 1910 	cjne	a,_operate,00107$
                                   1911 ;	main.c:536: ES = 0;		//禁止串口中断，防止蓝牙依然能够控制小车
                                   1912 ;	assignBit
      0005F2 C2 AC            [12] 1913 	clr	_ES
                                   1914 ;	main.c:537: ledStatus(1);
      0005F4 75 82 01         [24] 1915 	mov	dpl,#0x01
      0005F7 12r00r4E         [24] 1916 	lcall	_ledStatus
                                   1917 ;	main.c:538: selfControl();
      0005FA 12r02r0F         [24] 1918 	lcall	_selfControl
                                   1919 ;	main.c:539: ES = 1;
                                   1920 ;	assignBit
      0005FD D2 AC            [12] 1921 	setb	_ES
                                   1922 ;	main.c:540: ET2 = 1;	//退出自己控制，恢复定时器2中断允许
                                   1923 ;	assignBit
      0005FF D2 AD            [12] 1924 	setb	_ET2
      000601                       1925 00107$:
                                   1926 ;	main.c:542: operate = NO_OPERATE;
      000601 75*00 00         [24] 1927 	mov	_operate,#0x00
                                   1928 ;	main.c:543: }
      000604 22               [24] 1929 	ret
                                   1930 ;------------------------------------------------------------
                                   1931 ;Allocation info for local variables in function 'main'
                                   1932 ;------------------------------------------------------------
                                   1933 ;	main.c:545: void main() {
                                   1934 ;	-----------------------------------------
                                   1935 ;	 function main
                                   1936 ;	-----------------------------------------
      000605                       1937 _main:
                                   1938 ;	main.c:547: if (isFirst) {
      000605 30*01 05         [24] 1939 	jnb	_isFirst,00104$
                                   1940 ;	main.c:548: setup();
      000608 12r05rBF         [24] 1941 	lcall	_setup
                                   1942 ;	main.c:549: isFirst = 0;
                                   1943 ;	assignBit
      00060B C2*01            [12] 1944 	clr	_isFirst
                                   1945 ;	main.c:551: while(1) {
      00060D                       1946 00104$:
                                   1947 ;	main.c:552: loop();
      00060D 12r05rCE         [24] 1948 	lcall	_loop
                                   1949 ;	main.c:554: }
      000610 80 FB            [24] 1950 	sjmp	00104$
                                   1951 	.area CSEG    (CODE)
                                   1952 	.area CONST   (CODE)
      000000                       1953 _seg:
      000000 C0                    1954 	.db #0xc0	; 192
      000001 F9                    1955 	.db #0xf9	; 249
      000002 A4                    1956 	.db #0xa4	; 164
      000003 B0                    1957 	.db #0xb0	; 176
      000004 99                    1958 	.db #0x99	; 153
      000005 92                    1959 	.db #0x92	; 146
      000006 82                    1960 	.db #0x82	; 130
      000007 F8                    1961 	.db #0xf8	; 248
      000008 80                    1962 	.db #0x80	; 128
      000009 90                    1963 	.db #0x90	; 144
      00000A 88                    1964 	.db #0x88	; 136
      00000B 83                    1965 	.db #0x83	; 131
      00000C C6                    1966 	.db #0xc6	; 198
      00000D A1                    1967 	.db #0xa1	; 161
      00000E 86                    1968 	.db #0x86	; 134
      00000F 8E                    1969 	.db #0x8e	; 142
                                   1970 	.area XINIT   (CODE)
                                   1971 	.area CABS    (ABS,CODE)
